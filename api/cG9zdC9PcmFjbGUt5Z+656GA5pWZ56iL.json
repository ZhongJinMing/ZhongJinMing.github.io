{"title":"Oracle-基础教程","date":"2019-08-13T10:01:54.000Z","link":"post/Oracle-基础教程","comments":true,"tags":["oracle"],"categories":["数据库"],"updated":"2019-08-13T10:03:04.487Z","content":"<h2 id=\"Oracle基础\">Oracle基础<a href=\"post/Oracle-基础教程#Oracle基础\"></a></h2><h4 id=\"SELECT语句\">SELECT语句<a href=\"post/Oracle-基础教程#SELECT语句\"></a></h4><ol>\n<li><p>语法：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">  column_1, </span><br><span class=\"line\">  column_2, </span><br><span class=\"line\">  ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">  table_name;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>请注意，<strong>只能使用星号(*)进行测试</strong>。 在实践中，即使想要从表的所有列中检索数据，也<strong>应该明确指定要从中查询数据的列</strong>。<br>这是因为业务变化，表格未来可能会有更多或更少的列。 如果在应用程序代码中使用星号(*)，并假定该表有一组固定的列，<strong>但应用程序可能不处理其他不相关的列或访问已删除的列</strong>。</p>\n</li>\n</ol>\n<h4 id=\"ORDER-BY子句\">ORDER BY子句<a href=\"post/Oracle-基础教程#ORDER-BY子句\"></a></h4><ol>\n<li><p>在Oracle中，<strong>表中是以非指定顺序存储行数据记录的</strong>，它不管行插入数据库的顺序如何。要按列以升序或降序查询行记录，必须明确指示Oracle数据库要如何去排序。</p>\n</li>\n<li><p>语法：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    column_1,</span><br><span class=\"line\">    column_2,</span><br><span class=\"line\">    column_3,</span><br><span class=\"line\">    ...</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span></span><br><span class=\"line\">    column_1 [<span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span>] [<span class=\"keyword\">NULLS</span> <span class=\"keyword\">FIRST</span> | <span class=\"keyword\">NULLS</span> <span class=\"keyword\">LAST</span>],</span><br><span class=\"line\">    column_1 [<span class=\"keyword\">ASC</span> | <span class=\"keyword\">DESC</span>] [<span class=\"keyword\">NULLS</span> <span class=\"keyword\">FIRST</span> | <span class=\"keyword\">NULLS</span> <span class=\"keyword\">LAST</span>],</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p><code>NULLS FIRST</code>在非<code>NULL</code>值之前放置NULL值，<code>NULLS LAST</code>在非NULL值之后放置<code>NULL</code>值</p>\n</li>\n<li><p>请注意，<code>ORDER BY</code>子句总是<code>SELECT</code>语句中的最后一个子句</p>\n</li>\n<li><p>要对多列进行排序，可以用逗号分隔<code>ORDER BY</code>子句中的每列。</p>\n</li>\n<li><p>不需要指定用于排序数据的列名称。如果您愿意，可以使用<code>ORDER BY</code>子句中列的位置。请参考下语句：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">name</span>, credit_limit,address</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"number\">2</span> <span class=\"keyword\">DESC</span>, <span class=\"number\">1</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在这个例子中，name列的位置是1，credit_limit列的位置是2</p>\n<ol start=\"7\">\n<li>当使用非NULL值对混合<code>NULL</code>进行排序时，Oracle允许指定哪个应该首先出现。要放置<code>NULL</code>值在后面，可以使用<code>NULLS LAST</code></li>\n<li><code>ORDERBY</code>子句可在一列上应用一个函数，例如字符串函数，数学函数等，并按函数的结果对数据进行排序。<br>例如，以下语句使用<code>ORDER BY</code>子句中的<code>UPPER()</code>函数来区分客户名称的大小写：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> customer_id, <span class=\"keyword\">name</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span> customers</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">UPPER</span>( <span class=\"keyword\">name</span> );</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<h4 id=\"SELECT-DISTINCT语句\">SELECT DISTINCT语句<a href=\"post/Oracle-基础教程#SELECT-DISTINCT语句\"></a></h4><ol>\n<li>请注意，<code>DISTINCT</code>不是SQL标准的<code>UNIQUE</code>的同义词。<strong>总是使用<code>DISTINCT</code>而不使用<code>UNIQUE</code>是一个好的习惯</strong>。</li>\n<li><code>DISTINCT</code>将<code>NULL</code>值视为重复值。如果使用<code>SELECT DISTINCT</code>语句从具有多个<code>NULL</code>值的列中查询数据，则结果集只包含一个<code>NULL</code>值。</li>\n</ol>\n<h4 id=\"WHERE子句\">WHERE子句<a href=\"post/Oracle-基础教程#WHERE子句\"></a></h4><ol>\n<li><p>Oracle按以下顺序评估子句：<code>FROM WHERE</code>和<code>SELECT</code></p>\n<ul>\n<li><strong>首先</strong>，<code>FROM</code>子句指定查询数据的表。</li>\n<li><strong>其次</strong>，<code>WHERE</code>子句基于条件(例如<code>product_name =&#39;Kingston&#39;</code>过滤行记录)。</li>\n<li><strong>第三</strong>，<code>SELECT</code>子句选择了应该返回的列。</li>\n</ul>\n</li>\n<li><p>使用比较运算符选择行记录，除了等于(=)运算符之外，Oracle还提供了下表中所示的许多其他比较运算符：</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">编号</th>\n<th align=\"center\">运算符</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\"><code>=</code></td>\n<td align=\"center\">等于</td>\n</tr>\n<tr>\n<td align=\"center\">2</td>\n<td align=\"center\"><code>!=</code>, <code>&lt;&gt;</code></td>\n<td align=\"center\">不等于</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\"><code>&gt;</code></td>\n<td align=\"center\">大于</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\"><code>&lt;</code></td>\n<td align=\"center\">小于</td>\n</tr>\n<tr>\n<td align=\"center\">5</td>\n<td align=\"center\"><code>&gt;=</code></td>\n<td align=\"center\">大于或等于</td>\n</tr>\n<tr>\n<td align=\"center\">6</td>\n<td align=\"center\"><code>&lt;=</code></td>\n<td align=\"center\">小于或等于</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\"><code>IN</code></td>\n<td align=\"center\">等于值列表中的任何值</td>\n</tr>\n<tr>\n<td align=\"center\">8</td>\n<td align=\"center\"><code>ANY/SOME/ALL</code></td>\n<td align=\"center\">将值与列表或子查询进行比较.它必须以另一个运算符(例如：<code>=</code>,<code>&gt;</code>,<code>&lt;</code>)作为前缀</td>\n</tr>\n<tr>\n<td align=\"center\">9</td>\n<td align=\"center\"><code>NOT IN</code></td>\n<td align=\"center\">不等于值列表中的任何值</td>\n</tr>\n<tr>\n<td align=\"center\">10</td>\n<td align=\"center\"><code>[NOT] BETWEEN n AND m</code></td>\n<td align=\"center\">相当于<code>[Not] &gt;= n</code>且<code>&lt;= y</code></td>\n</tr>\n<tr>\n<td align=\"center\">11</td>\n<td align=\"center\"><code>[NOT] EXISTS</code></td>\n<td align=\"center\">如果子查询返回至少一行，则返回<code>true</code></td>\n</tr>\n<tr>\n<td align=\"center\">12</td>\n<td align=\"center\"><code>IS [NOT] NULL</code></td>\n<td align=\"center\">测试<code>NULL</code>的值</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"AND和OR运算符\">AND和OR运算符<a href=\"post/Oracle-基础教程#AND和OR运算符\"></a></h4><ol>\n<li>在声明中使用多个逻辑运算符时，Oracle始终首先评估<code>AND</code>运算符。但是，可以使用括号来更改评估的顺序</li>\n<li>如果在语句中使用多个逻辑运算符，则Oracle会在评估<code>NOT</code>和<code>AND</code>运算符之后评估<code>OR</code>运算符。 但是，可以使用括号更改评估的顺序</li>\n<li>可以使用IN运算符来代替使用多个OR运算符</li>\n</ol>\n<h4 id=\"FETCH子句\">FETCH子句<a href=\"post/Oracle-基础教程#FETCH子句\"></a></h4><ol>\n<li><p>语法：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ OFFSET offset ROWS]</span><br><span class=\"line\"> FETCH  NEXT [  row_count | percent PERCENT  ] ROWS  [ ONLY | <span class=\"keyword\">WITH</span> <span class=\"keyword\">TIES</span> ]</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p><code>OFFSET</code>子句指定在行限制开始之前要跳过行数。<code>OFFSET</code>子句是可选的。 如果跳过它，则偏移量为0，行限制从第一行开始计算。偏移量必须是一个数字或一个表达式，其值为一个数字。偏移量遵守以下规则:</p>\n<ul>\n<li>如果偏移量是负值，则将其视为0</li>\n<li>n如果偏移量为NULL或大于查询返回的行数，则不返回任何行</li>\n<li>如果偏移量包含一个分数，则分数部分被截断</li>\n</ul>\n</li>\n<li><p><code>FETCH</code>子句指定要返回的行数或百分比。为了语义清晰的目的，您可以使用关键字<code>ROW</code>而不是<code>ROWS</code>，<code>FIRST</code>而不是<code>NEXT</code>。 例如，以下子句的行为和产生的结果相同:</p>\n<ul>\n<li><code>FETCH NEXT 1 ROWS</code></li>\n<li><code>FETCH FIRST 1 ROW</code></li>\n</ul>\n</li>\n<li><p><code>ONLY | WITH TIES</code>选项</p>\n<ul>\n<li>仅返回<code>FETCH NEXT</code>(或<code>FIRST</code>)后的行数或行数的百分比。    </li>\n<li><code>WITH TIES</code>返回与最后一行相同的排序键。请注意，如果使用<code>WITH TIES</code>，则必须在查询中指定一个<code>ORDER BY</code>子句。如果不这样做，查询将不会返回额外的行。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"LIKE运算符\">LIKE运算符<a href=\"post/Oracle-基础教程#LIKE运算符\"></a></h4><ol>\n<li>LIKE运算符的语法：<code>expresion [NOT] LIKE pattern [ ESCAPE escape_characters ]</code></li>\n<li>在上面的语法中，<ol>\n<li>expression - 该表达式是一个列名称或一个表达式，要针对该模式(pattern)进行测试</li>\n<li>pattern - 该模式是在表达式中搜索的字符串。此模式包含以下通配符：<ul>\n<li>％(百分号)匹配<strong>零个或多个字符</strong>的<strong>任何字符串</strong></li>\n<li>_(下划线)匹配<strong>任何单个字符</strong></li>\n</ul>\n</li>\n<li>escape_character <code>- escape_character</code>是出现在通配符前面的字符，用于指定通配符不应被解释为通配符而是常规字符。</li>\n<li><code>escape_character</code>(如果指定)必须是一个字符，并且没有默认值</li>\n</ol>\n</li>\n<li>ESCAPE子句允许查找<strong>包含一个或多个通配符的字符串</strong>。<br> 例如，表可能包含具有百分比字符的数据，例如折扣值，折旧率。要搜索字符串25％，可以使用ESCAPE子句，如下所示：<br> <code>LIKE &#39;%25!%%&#39; ESCAPE &#39;!&#39;</code><br> 如果不使用ESCAPE子句，则Oracle将返回字符串为25的任何行</li>\n</ol>\n<h4 id=\"JOIN语法\">JOIN语法<a href=\"post/Oracle-基础教程#JOIN语法\"></a></h4><h6 id=\"INNER-JOIN\">INNER JOIN<a href=\"post/Oracle-基础教程#INNER-JOIN\"></a></h6><ol>\n<li>查询通过基于连接谓词组合表T1和T2的列值来返回结果集。它将表T1的每一行与表T2的行进行比较，以查找满足连接谓词的所有行记录。只要通过匹配非NULL值来满足连接谓词，则T1和T2表的<strong>每对匹配行的列值</strong>就会被<strong>合并到结果集中的一行中</strong></li>\n<li>除<code>ON</code>子句外，还可以使用<code>USING</code>子句指定在连接表时要测试哪些列的相等性  <blockquote>\n<p>请注意，<code>USING</code>子句中列出的列(如c1和c2)必须在T1和T2表中都存在(可用)</p>\n</blockquote>\n</li>\n</ol>\n<h6 id=\"LEFT-JOIN\">LEFT JOIN<a href=\"post/Oracle-基础教程#LEFT-JOIN\"></a></h6><ol>\n<li>左连接(Left join)返回左表中的<strong>所有行</strong>，并从右表中返回<strong>匹配的行</strong></li>\n<li>ON与WHERE子句中的条件<br> 以下语句查询获得订单ID为58的订单和销售员数据<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    order_id,</span><br><span class=\"line\">    <span class=\"keyword\">status</span>,</span><br><span class=\"line\">    employee_id,</span><br><span class=\"line\">    last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    orders</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees <span class=\"keyword\">ON</span></span><br><span class=\"line\">    employee_id = salesman_id</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    order_id = <span class=\"number\">58</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>现在，如果将条件从WHERE子句移动到LEFT JOIN的ON子句：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    order_id,</span><br><span class=\"line\">    <span class=\"keyword\">status</span>,</span><br><span class=\"line\">    employee_id,</span><br><span class=\"line\">    last_name</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    orders</span><br><span class=\"line\"><span class=\"keyword\">LEFT</span> <span class=\"keyword\">JOIN</span> employees <span class=\"keyword\">ON</span></span><br><span class=\"line\">    employee_id = salesman_id</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> order_id = <span class=\"number\">58</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>在这种情况下，<strong>查询将返回所有订单，但只有订单58具有与其关联的销售员数据</strong>，<br>请注意，<strong>对于内连接，置于ON中的条件与置于WHERE子句中的条件相同</strong></p>\n<h6 id=\"CROSS-JOIN子句\">CROSS JOIN子句<a href=\"post/Oracle-基础教程#CROSS-JOIN子句\"></a></h6><ol>\n<li>与其他连接(如<code>INNER JOIN</code>或<code>LEFT JOIN</code>)不同，<code>CROSS JOIN</code>没有连接谓词的ON子句</li>\n</ol>\n<h6 id=\"自连接\">自连接<a href=\"post/Oracle-基础教程#自连接\"></a></h6><ol>\n<li><p>自连接是连接表与自身的连接。自连接对比较表中的行或查询分层数据非常有用。<br> 自连接使用其他连接，如内连接和左连接。 另外，它使用表别名在同一查询中为表提供不同的名称。  </p>\n<blockquote>\n<p><strong>请注意，在不使用表别名的情况下，在查询中多次引用同一个表会导致错误</strong>。  </p>\n</blockquote>\n<p> 以下说明了表T如何与自身连接：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    column_list</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    T t1</span><br><span class=\"line\"><span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> T t2 <span class=\"keyword\">ON</span></span><br><span class=\"line\">    join_predicate;</span><br></pre></td></tr></table></div></figure>\n\n<p>请注意，除了<code>INNER JOIN</code>之外，还可以在上面的语句中使用<code>LEFT JOIN</code></p>\n</li>\n</ol>\n<h4 id=\"GROUP-BY子句\">GROUP BY子句<a href=\"post/Oracle-基础教程#GROUP-BY子句\"></a></h4><ol>\n<li><code>GROUP BY</code>子句在SELECT语句中用于按行或表达式的值将行组合到分组汇总的行中。 <strong><code>GROUP BY</code>子句为每个分组返回一行</strong>。</li>\n<li><code>GROUP BY</code>子句出现在FROM子句之后。在有提供<code>WHERE</code>子句的情况下，<code>GROUP BY</code>子句必须放在WHERE子句之前。<br> GROUP BY子句按分组列中的值(如c1，c2和c3)对进行分组。GROUP BY子句只能包含聚合或分组的列。</li>\n</ol>\n<h4 id=\"HAVING子句\">HAVING子句<a href=\"post/Oracle-基础教程#HAVING子句\"></a></h4><ol>\n<li><code>HAVING</code>子句是SELECT语句的可选子句。<strong>它用于过滤由<code>GROUP BY</code>子句返回的行分组</strong>。 这就是为什么<code>HAVING</code>子句通常与<code>GROUP BY</code>子句一起使用的原因。</li>\n<li>请注意，<strong><code>HAVING</code>子句过滤分组的行</strong>，而<strong><code>WHERE</code>子句过滤行</strong>。这是<code>HAVING</code>和<code>WHERE</code>子句之间的主要区别。</li>\n<li><code>HAVING</code>子句为什么不能使用列的别名：<br> 虽然聚合函数在<code>GROUP BY</code>之前执行，但是只有在<code>SELECT</code>执行后才能产生别名，而<strong><code>SELECT</code>在<code>GROUP BY</code>后执行</strong>，同理，因为<strong><code>ORDER BY</code>在<code>SELECT</code>后执行，所以可以使用列的别名</strong></li>\n</ol>\n<h4 id=\"子查询\">子查询<a href=\"post/Oracle-基础教程#子查询\"></a></h4><ol>\n<li>子查询嵌套在外部查询中。<strong>请注意，子查询必须出现在括号内</strong>。</li>\n<li>嵌套在<code>SELECT</code>语句的<code>FROM</code>子句中的子查询称为<strong>内联视图</strong>。请注意，其他RDBMS(如MySQL和PostgreSQL)使用术语<strong>派生表</strong>，而不是内联视图。<br> 嵌套在<code>SELECT</code>语句的<code>WHERE</code>子句中的子查询称为<strong>嵌套子查询</strong>。</li>\n<li>子查询可以包含另一个子查询。Oracle允许在顶级查询的FROM子句中使用无限数量的子查询级别，<strong>并在WHERE子句中使用多达255个子查询级别</strong>。</li>\n<li>下面是子查询的主要优点：<ul>\n<li>提供一种替代方法来解决查询需要复杂联接和联合的数据</li>\n<li>使复杂的查询更具可读性</li>\n<li>允许以一种可以隔离每个部分的方式来构建复杂的查询</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Exists运算符\">Exists运算符<a href=\"post/Oracle-基础教程#Exists运算符\"></a></h4><ol>\n<li>Oracle Exists运算符是返回true或false的布尔运算符。EXISTS运算符通常与子查询一起使用来测试行的存在：  <figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span></span><br><span class=\"line\">        <span class=\"keyword\">EXISTS</span>(subquery);</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>如果子查询返回任何行，则<code>EXISTS</code>运算符返回true，否则返回false。 另外，当子查询返回第一行，<code>EXISTS</code>操作符终止子查询的处理。</p>\n<ol start=\"2\">\n<li><p>如果<code>WHERE</code>子句使用<code>EXISTS</code>运算符来检索子查询的客户，则返回相关的行。</p>\n<blockquote>\n<p>请注意，Oracle<strong>会忽略子查询中的选择列表</strong>，因此您可以使用<strong>任何列，字面值，表达式</strong>等。在上面的查询中是使用了文字数字值： 1。</p>\n<ol start=\"3\">\n<li>Oracle EXISTS与IN<br><code>EXISTS</code>操作符在子查询返回第一行时停止扫描行，因为它可以确定结果，而<code>IN</code>操作符必须扫描子查询返回的所有行以结束结果。<br>另外，<code>IN</code>子句不能与NULL值进行任何比较，但<code>EXISTS</code>子句可以将所有值与NULL值进行比较。例如，第一个语句不返回行记录，而第二个语句返回customers表中的所有行：</li>\n</ol>\n</blockquote>\n<p> -- 第一个语句</p>\n <figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    customer_id <span class=\"keyword\">IN</span>(<span class=\"literal\">NULL</span>);</span><br></pre></td></tr></table></div></figure>\n\n<p> -- 第二个语句</p>\n <figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    customers</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    <span class=\"keyword\">EXISTS</span> (</span><br><span class=\"line\">        <span class=\"keyword\">SELECT</span></span><br><span class=\"line\">            <span class=\"literal\">NULL</span></span><br><span class=\"line\">        <span class=\"keyword\">FROM</span></span><br><span class=\"line\">            dual</span><br><span class=\"line\">    );</span><br></pre></td></tr></table></div></figure>\n\n<p> 通常，<strong>当子查询的结果集较大时，<code>EXISTS</code>运算符比<code>IN</code>运算符更快。相比之下，当子查询的结果集很小时，<code>IN</code>运算符比<code>EXISTS</code>运算符更快</strong>。</p>\n</li>\n<li><p>NOT EXISTS与NOT IN<br> 以下语句对子查询使用<code>IN</code>运算符：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\"> *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> <span class=\"keyword\">IN</span>(subquery);</span><br></pre></td></tr></table></div></figure>\n\n<p> 假设子查询返回四个值：1,2,3和<code>NULL</code>。可以重写上面的整个查询，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    <span class=\"keyword\">id</span> = <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">OR</span> <span class=\"keyword\">id</span> = <span class=\"number\">2</span>  </span><br><span class=\"line\">    <span class=\"keyword\">OR</span> <span class=\"keyword\">id</span> = <span class=\"number\">3</span></span><br><span class=\"line\">    <span class=\"keyword\">OR</span> <span class=\"keyword\">id</span> = <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p> 下面的表达式<strong>总是返回一个<code>NULL</code>值</strong>，因为<strong><code>NULL</code>值不能和任何东西比较</strong>。<br> <code>id = NULL</code><br> 因此，<strong>如果子查询的结果集中的任何行为<code>NULL</code>，则以下表达式将返回<code>NULL</code>值</strong>。<br> <strong><code>id NOT IN (subquery)</code></strong><br> 相比之下，<code>NULL</code>不会影响<code>NOT EXIST</code>运算符的结果，因为<code>NOT EXISTS</code>运算符仅检查子查询中是否存在行：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span>(subquery);</span><br></pre></td></tr></table></div></figure>\n\n<p> 总而言之，当存在<code>NULL</code>值时，<code>NOT EXISTS</code>和<code>NOT IN</code>的行为会有所不同。</p>\n</li>\n</ol>\n<h4 id=\"ANY运算符\">ANY运算符<a href=\"post/Oracle-基础教程#ANY运算符\"></a></h4><ol>\n<li>Oracle <code>ANY</code>运算符用于将值与子查询返回的值或结果集列表进行比较。下面举例说明ANY运算符与列表或子查询一起使用时的语法：<br><code>operator ANY ( v1, v2, v3)</code><br><code>operator ANY ( subquery)</code><br>在这个语法中：<ul>\n<li><strong><code>ANY</code>运算符前面必须有一个运算符</strong>，例如：=，!=，&gt;，&gt;=，&lt;，&lt;=。</li>\n<li><strong>列表或子查询必须用圆括号包围</strong>。</li>\n</ul>\n</li>\n<li>如果使用<code>ANY</code>运算符将一个值与子查询返回的结果集进行比较，则Oracle<strong>使用<code>EXISTS</code>运算符将查询转换为等效的查询，而不使用<code>ANY</code>运算符</strong>。</li>\n<li>请注意，<strong>如果子查询不返回任何行，则以下条件的计算结果为false</strong>：<br><code>operator ANY (subquery)</code><br>因此，整个查询不返回行</li>\n<li>在Oracle中，<strong><code>SOME</code>和<code>ANY</code>的行为完全相同</strong>，因此它们完全可以互换</li>\n</ol>\n<h4 id=\"ALL操作符\">ALL操作符<a href=\"post/Oracle-基础教程#ALL操作符\"></a></h4><ol>\n<li>Oracle <code>ALL</code>操作符用于将值与子查询返回的值列表或结果集进行比较。<br>以下显示了与列表或子查询一起使用的<code>ALL</code>运算符的语法：<br><code>operator ALL ( v1, v2, v3)</code><br><code>operator ALL ( subquery)</code><br>在这个语法中，  <ul>\n<li><strong><code>ALL</code>运算符前面必须有一个运算符</strong>，例如：=，!=,&gt;，&gt;=，&lt;，&lt;=，后跟一个列表或子查询。</li>\n<li>列表或子查询必须用圆括号包围。</li>\n</ul>\n</li>\n<li>使用<code>ALL</code>运算符将值与列表进行比较时，Oracle将初始条件扩展到列表的所有元素，并使用<code>AND</code>运算符将它们组合在一起，如下所示：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    c &gt; <span class=\"keyword\">ALL</span> (</span><br><span class=\"line\">        v1,</span><br><span class=\"line\">        v2,</span><br><span class=\"line\">        v3</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">--  以上语句转换为 ALL 运算符后</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    c &gt; v1</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> c &gt; v2</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> c &gt; v3;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>如果使用<code>ALL</code>运算符将值与子查询返回的结果集进行比较，则Oracle执行两步转换，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> product_name,</span><br><span class=\"line\">       list_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> list_price &gt; <span class=\"keyword\">ALL</span></span><br><span class=\"line\">    ( <span class=\"keyword\">SELECT</span> list_price</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span> products</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> category_id = <span class=\"number\">1</span> )</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> product_name;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 1st step: transformation that uses ANY</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> product_name,</span><br><span class=\"line\">       list_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products p1</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">NOT</span>( p1.list_price &lt;= <span class=\"keyword\">ANY</span></span><br><span class=\"line\">            (<span class=\"keyword\">SELECT</span> list_price</span><br><span class=\"line\">             <span class=\"keyword\">FROM</span> products p2</span><br><span class=\"line\">             <span class=\"keyword\">WHERE</span> category_id = <span class=\"number\">1</span> ))</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> product_name; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 2nd step: transformation that eliminates ANY</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> product_name,</span><br><span class=\"line\">       list_price</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> products p1</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">EXISTS</span></span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> p2.list_price</span><br><span class=\"line\">     <span class=\"keyword\">FROM</span> products p2</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> p2.category_id = <span class=\"number\">1</span></span><br><span class=\"line\">       <span class=\"keyword\">AND</span> p2.list_price &gt;= p1.list_price )</span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> product_name;</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"3\">\n<li>如果子查询不返回行，则以下条件的计算结果为true：<br><code>operator ALL (subquery)</code><br>这意味着在WHERE子句中使用上述条件的查询将返回所有行，以防子查询返回任何行。  <figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    <span class=\"keyword\">col</span> <span class=\"keyword\">operator</span> <span class=\"keyword\">ALL</span>(subquery);</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<h4 id=\"UNION运算符\">UNION运算符<a href=\"post/Oracle-基础教程#UNION运算符\"></a></h4><ol>\n<li><code>UNION</code>运算符是一个集合运算符，它将两个或多个SELECT语句的结果集组合到一个结果集中。<br> 以下说明了组合两个查询的结果集的UNION运算符的语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    column_list_1</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    T1</span><br><span class=\"line\"><span class=\"keyword\">UNION</span> </span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    column_list_1</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    T2;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在此声明中，column_list_1和column_list_2<strong>必须具有相同顺序的相同列数</strong>。 另外，<strong>对应列的数据类型必须是相同的数据类型组</strong>，例如数字或字符。</p>\n<ol start=\"2\">\n<li>要对由<code>UNION</code>运算符返回的结果集进行排序，可以将<code>ORDER BY</code>子句添加到最后一个<code>SELECT</code>语句中</li>\n<li><code>UNION</code>运算符<strong>删除(消除)重复的行</strong>，<code>UNION ALL</code>操作符<strong>不会删除重复的行</strong></li>\n<li><code>UNION</code>将结果集放置在另一个上面，这意味着它将<strong>垂直地附加结果集</strong>。但是，诸如<strong><code>INNER JOIN</code>或<code>LEFT JOIN</code>的连接将结果集水平组合</strong>。</li>\n</ol>\n<h4 id=\"INTERSECT运算符\">INTERSECT运算符<a href=\"post/Oracle-基础教程#INTERSECT运算符\"></a></h4><ol>\n<li><code>INTERSECT</code>运算符来比较两个查询，并返回由两者相交的行</li>\n<li>与UNION运算符相似，使用INTERSECT运算符时必须遵循以下规则：<ul>\n<li><strong>两个查询中列的数量和顺序必须相同</strong>。</li>\n<li>相应列的数据类型必须处于<strong>相同的数据类型组中</strong>，例如数字或字符。        </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"MINUS操作符\">MINUS操作符<a href=\"post/Oracle-基础教程#MINUS操作符\"></a></h4><ol>\n<li><code>MINUS</code>运算符比较两个查询，并返回第一个查询中但不是第二个查询输出的行。 换句话说，<code>MINUS</code>运算符<strong>从一个结果集中减去另一个结果集</strong>。</li>\n<li>与UNION和INTERSECT操作符类似，上面的查询必须符合以下规则：<ul>\n<li><strong>列数和它们的顺序必须匹配一致</strong>。</li>\n<li>相应列的数据类型必须处于<strong>相同的数据类型组中</strong>，例如数字或字符。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"INSERT语句\">INSERT语句<a href=\"post/Oracle-基础教程#INSERT语句\"></a></h4><ol>\n<li>要将新行插入到表中，请按如下方式使用<code>INSERT</code>语句：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name (column_1, column_2, column_3, ... column_n)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span>( value_1, value_2, value_3, ..., value_n);</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在这个声明语句中：<br>    * 首先，指定要插入的表的名称 - table_name。<br>    * 其次，在圆括号内指定逗号分隔列名的列表。<br>    * 第三，指定对应于列列表的逗号分隔值列表。</p>\n<pre><code>如果值列表与表列具有相同的顺序，则可以跳过不指定列的列表，但**这不被认为是一种好的做法**：\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span> (value_1, value_2, value_3, ..., value_n);</span><br></pre></td></tr></table></div></figure>\n\n如果从`INSERT`语句中排除一列或多列，则必须指定列列表，因为Oracle需要它与值列表中的值相匹配。   \n在`INSERT`语句中省略的列**将使用缺省值(如果可用)或者如果列接受`NULL`值，则使用`NULL`值**。</code></pre><h4 id=\"INSERT-INTO-SELECT语句\">INSERT INTO SELECT语句<a href=\"post/Oracle-基础教程#INSERT-INTO-SELECT语句\"></a></h4><ol>\n<li>有时候，想要将从其它表中选择数据并将其插入到另一个表中。要做到这一点，可使用<code>INSERT INTO SELECT</code>语句，如下所示：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> target_table (col1, col2, col3)</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> col1,</span><br><span class=\"line\">       col2,</span><br><span class=\"line\">       col3</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> source_table</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> condition;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p><code>INSERT INTO SELECT</code>语句<strong>要求源表和目标表匹配数据类型</strong>。</p>\n<h4 id=\"Insert-All语句\">Insert All语句<a href=\"post/Oracle-基础教程#Insert-All语句\"></a></h4><ol>\n<li>Oracle提供了两种类型的多项式插入语句：无条件的和有条件的。</li>\n<li>无条件的<code>INSERT ALL</code>语句<br>将多行插入到表中，要将多行插入到表中，请使用以下<code>INSERT ALL</code>语句：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">ALL</span></span><br><span class=\"line\">    <span class=\"keyword\">INTO</span> table_name(col1,col2,col3) <span class=\"keyword\">VALUES</span>(val1,val2, val3)</span><br><span class=\"line\">    <span class=\"keyword\">INTO</span> table_name(col1,col2,col3) <span class=\"keyword\">VALUES</span>(val4,val5, val6)</span><br><span class=\"line\">    <span class=\"keyword\">INTO</span> table_name(col1,col2,col3) <span class=\"keyword\">VALUES</span>(val7,val8, val9)</span><br><span class=\"line\">Subquery;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在这个语句中，每个值表达式值：val1，val2或val3必须引用由子查询的选择列表返回的列对应的值。<br>如果要使用文字值而不是子查询返回的值，请使用以下子查询：<br><code>SELECT * FROM dual;</code></p>\n<ol start=\"3\">\n<li>有条件的<code>INSERT ALL</code>语句<br>条件多项插入语句允许根据指定的条件将行插入到表中。<br>以下显示了条件多项插入语句的语法：  <figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> [ <span class=\"keyword\">ALL</span> | <span class=\"keyword\">FIRST</span> ]</span><br><span class=\"line\">    <span class=\"keyword\">WHEN</span> condition1 <span class=\"keyword\">THEN</span></span><br><span class=\"line\">        <span class=\"keyword\">INTO</span> table_1 (column_list ) <span class=\"keyword\">VALUES</span> (value_list)</span><br><span class=\"line\">    <span class=\"keyword\">WHEN</span> condition2 <span class=\"keyword\">THEN</span> </span><br><span class=\"line\">        <span class=\"keyword\">INTO</span> table_2(column_list ) <span class=\"keyword\">VALUES</span> (value_list)</span><br><span class=\"line\">    <span class=\"keyword\">ELSE</span></span><br><span class=\"line\">        <span class=\"keyword\">INTO</span> table_3(column_list ) <span class=\"keyword\">VALUES</span> (value_list)</span><br><span class=\"line\">Subquery</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>如果指定了<code>ALL</code>关键字，则Oracle将在WHEN子句中评估每个条件。如果条件评估/计算为true，则Oracle执行相应的<code>INTO</code>子句。<br>但是，当指定<code>FIRST</code>关键字时，对于由子查询返回的每一行，Oracle都会从<code>WHEN</code>子句的上下方向评估每个条件。 如果Oracle发现条件的计算结果为true，则执行相应的<code>INTO</code>子句并跳过给定行的后续<code>WHEN</code>子句。<br>请注意，单条件多项式插入语句最多可以有127个<code>WHEN</code>子句。</p>\n<ol start=\"4\">\n<li><code>INSERT ALL</code>限制<br>Oracle多表插入语句受以下主要限制：  <ul>\n<li>它可以用来将数据只插入到表中，而不是视图或物化视图。  </li>\n<li>它不能用来将数据插入到远程表中。  </li>\n<li>所有<code>INSERT INTO</code>子句中的列总和不得超过999。  </li>\n<li>一个表集合表达式不能在一个多表插入语句中使用。  </li>\n<li>多表插入语句的子查询不能使用序列。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"Delete语句\">Delete语句<a href=\"post/Oracle-基础教程#Delete语句\"></a></h4><ol>\n<li><p>要从表中删除一行或多行，请按如下所示使用<code>DELETE</code>语句：</p>\n <figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    condition;</span><br></pre></td></tr></table></div></figure>\n\n<p> 在这个语句中，</p>\n<ul>\n<li><p>首先，指定要从中删除数据的表的名称。</p>\n</li>\n<li><p>其次，通过使用<code>WHERE</code>子句中的条件指定应该删除哪些行。如果省略了<code>WHERE</code>子句，则<code>DELETE</code>语句将从表中删除所有行。</p>\n<p>请注意，<strong>使用TRUNCATE TABLE语句删除大型表中的所有行会更快更高效</strong>。</p>\n</li>\n</ul>\n</li>\n<li><p>级联删除<br>在现实应用中，经常从与其他表中的行具有外键关系的表中来删除行记录。<br>例如，想要从orders表中删除id为1的销售订单，并从order_items表中删除与订单id是1关联的所有行项目。 通常可以发出两个<code>DELETE</code>语句，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- 第一条</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span></span><br><span class=\"line\">    orders</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    order_id = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- 第二条</span></span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span></span><br><span class=\"line\">    order_items</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    order_id = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">COMMIT</span> <span class=\"keyword\">WORK</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>请注意，<strong><code>COMMIT WORK</code>语句确保两个<code>DELETE</code>语句以全部或全部方式执行</strong>，以防第一条语句成功，但第二个<code>DELETE</code>语句失败时在order_items表中的孤行。<br>但是，<strong>如果知道如何正确设置表的约束，那么这是不必要的</strong>。<br>在这种情况下，当创建order_items表时，可以使用<code>DELETE CASCADE</code>选项定义一个外键约束，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> order_items </span><br><span class=\"line\">(</span><br><span class=\"line\">    order_id   <span class=\"built_in\">NUMBER</span>( <span class=\"number\">12</span>, <span class=\"number\">0</span> )                                , </span><br><span class=\"line\">    <span class=\"comment\">-- other columns</span></span><br><span class=\"line\">    <span class=\"comment\">-- ...</span></span><br><span class=\"line\">    <span class=\"keyword\">CONSTRAINT</span> fk_order_items_orders </span><br><span class=\"line\">    <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span>( order_id ) </span><br><span class=\"line\">    <span class=\"keyword\">REFERENCES</span> orders( order_id ) </span><br><span class=\"line\">    <span class=\"keyword\">ON</span> <span class=\"keyword\">DELETE</span> <span class=\"keyword\">CASCADE</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></div></figure>\n\n<p>通过这样做，每当从orders表中删除一行时，例如：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    orders</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    order_id = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>order_items表中order_id为1的所有行也<strong>被数据库系统自动删除</strong></p>\n<h4 id=\"Merge语句\">Merge语句<a href=\"post/Oracle-基础教程#Merge语句\"></a></h4><ol>\n<li><code>MERGE</code>语句从一个或多个源表中选择数据并更新或将其插入到目标表中。 <code>MERGE</code>语句可指定一个条件来确定是更新数据还是将数据插入到目标表中。<br>以下说明了<code>MERGE</code>语句的语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">MERGE</span> <span class=\"keyword\">INTO</span> target_table </span><br><span class=\"line\"><span class=\"keyword\">USING</span> source_table </span><br><span class=\"line\"><span class=\"keyword\">ON</span> search_condition</span><br><span class=\"line\">    <span class=\"keyword\">WHEN</span> <span class=\"keyword\">MATCHED</span> <span class=\"keyword\">THEN</span></span><br><span class=\"line\">        <span class=\"keyword\">UPDATE</span> <span class=\"keyword\">SET</span> col1 = value1, col2 = value2,...</span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> &lt;update_condition&gt;</span><br><span class=\"line\">        [<span class=\"keyword\">DELETE</span> <span class=\"keyword\">WHERE</span> &lt;delete_condition&gt;]</span><br><span class=\"line\">    <span class=\"keyword\">WHEN</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">MATCHED</span> <span class=\"keyword\">THEN</span></span><br><span class=\"line\">        <span class=\"keyword\">INSERT</span> (col1,col2,...)</span><br><span class=\"line\">        <span class=\"keyword\">values</span>(value1,value2,...)</span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> &lt;insert_condition&gt;;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>下面来仔细看看上面<code>MERGE</code>语句的语法：<br>    * 首先，指定要在<code>INTO</code>子句中更新或插入的目标表(target_table)。<br>    * 其次，指定要更新或插入<code>USING</code>子句中的数据源(source_table)。<br>    * 第三，指定合并操作在<code>ON</code>子句中更新或插入的搜索条件。</p>\n<ol start=\"2\">\n<li><p>对于目标表中的每一行，Oracle都会评估搜索条件：  </p>\n<ul>\n<li><p>如果结果为true，则Oracle使用源表(source_table)中的相应数据更新该行。  </p>\n</li>\n<li><p>如果任何行的结果为false，则Oracle将源表(source_table)中相应的行插入到目标表(target_table)中。</p>\n<p>当想要在单个操作中组合多个<code>INSERT</code>，<code>UPDATE</code>和<code>DELETE</code>语句时，<code>MERGE</code>语句变得很方便。<br>因为<code>MERGE</code>是确定性语句，所以不能在同一个<code>MERGE</code>语句中多次更新目标表的同一行。<br>可以将一个可选的<code>DELETE WHERE</code>子句添加到<code>MATCHED</code>子句中，以在合并操作之后进行清理。<code>DELETE</code>子句只删除目标表中与<code>ON</code>和<code>DELETE WHERE</code>子句匹配的行。</p>\n</li>\n</ul>\n</li>\n<li><p>MERGE前提条件<br> 要执行MERGE语句，<strong>必须在源表上具有INSERT和UPDATE对象权限</strong>。<br> 如果使用DELETE子句，则还必须在目标表上具有DELETE对象特权。</p>\n</li>\n</ol>\n<h4 id=\"Create-Table语句\">Create Table语句<a href=\"post/Oracle-基础教程#Create-Table语句\"></a></h4><ol>\n<li>要在Oracle数据库中创建一个新表，可以使用<code>CREATE TABLE</code>语句。下面说明了<code>CREATE TABLE</code>语句的基本语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> schema_name.table_name (</span><br><span class=\"line\">    column_1 data_type column_constraint,</span><br><span class=\"line\">    column_2 data_type column_constraint,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    table_constraint</span><br><span class=\"line\"> );</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在上面这个语法中，<br>    * 首先，在CREATE TABLE子句中，指定新表所属的表名和模式名称。<br>    * 其次，在圆括号内列出所有列。 如果一个表有多个列，则需要用逗号分隔每个列的定义。列定义包括列名    * ，后跟它的数据类型，例如NUMBER，VARCHAR2和列约束，如NOT NULL，主键，约束检查等。<br>    * 第三，如果适用，例如：主键，外键，约束检查，则为表添加约束。</p>\n<blockquote>\n<p>请注意用户权限问题，必须具有CREATE TABLE系统特权才能在模式中创建新表，并使用CREATE ANY TABLE系统特权在其他用户的模式中创建新表。除此之外，新表的所有者必须具有包含新表或UNLIMITED TABLESPACE系统特权的表空间的配额。</p>\n</blockquote>\n<h4 id=\"Drop-Table语句\">Drop Table语句<a href=\"post/Oracle-基础教程#Drop-Table语句\"></a></h4><ol>\n<li>要将表移动到回收站或将其从数据库中完全删除，请使用<code>DROP TABLE</code>语句：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> schema_name.table_name</span><br><span class=\"line\">[<span class=\"keyword\">CASCADE</span> <span class=\"keyword\">CONSTRAINTS</span> | <span class=\"keyword\">PURGE</span>];</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在这个语句中：<br>    * 首先，指出要在<code>DROP TABLE</code>子句之后删除的表及其模式。如果不明确指定模式名称，则该语句假定将从模式中删除该表。<br>    * 其次，指定<code>CASCADE CONSTRAINTS</code>子句删除引用表中主键和唯一键的所有参照完整性约束。     如果存在这种引用完整性约束，并且不使用此子句，Oracle将返回错误并停止删除表。<br>    * 第三，如果想删除表格并且一次释放与之关联的空间，指定<code>PURGE</code>子句。 通过使用<code>PURGE</code>子句，Oracle不会将表及其依赖对象放入回收站。</p>\n<blockquote>\n<p>请注意，PURGE子句不允许您回滚或恢复删除的表。 因此，如果不希望敏感数据出现在回收站中，这很有用。</p>\n</blockquote>\n<h4 id=\"Alter-Table-Modify列语句\">Alter Table Modify列语句<a href=\"post/Oracle-基础教程#Alter-Table-Modify列语句\"></a></h4><ol>\n<li>要更改表中列的定义，请按如下所示使用<code>ALTER TABLE MODIFY</code>列语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> column_name <span class=\"keyword\">action</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>语句很直接。要修改表的列，需要指定要执行的列名，表名和操作。<br>Oracle允许执行多种操作，但以下是主要常用的操作：<br>    * 修改列的可见性<br>    * 允许或不允许NULL值<br>    * 缩短或扩大列的大小<br>    * 更改列的默认值<br>    * 修改虚拟列的表达式</p>\n<pre><code>要修改多个列，请使用以下语法：</code></pre><figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> (</span><br><span class=\"line\">    column_name_1 <span class=\"keyword\">action</span>,</span><br><span class=\"line\">    column_name_2 <span class=\"keyword\">action</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">);</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"2\">\n<li>修改列的可见性<br> 可以将表列定义为不可见或可见。<strong>不可见列不可用于查询</strong>，但是，可以通过<strong>在查询中显式指定不可见列来查询</strong><br> 默认情况下，表列是可见的。可以在创建表或使用<code>ALTER TABLE MODIFY</code>列语句时定义不可见列。<br> 例如，以下语句使full_name列不可见：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> accounts </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> full_name <span class=\"keyword\">INVISIBLE</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>要将列从不可见变为可见，请使用以下语句：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> accounts </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> full_name <span class=\"keyword\">VISIBLE</span>;</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"3\">\n<li>允许或不允许null示例<br> 以下语句将email列更改为接受非空(not null)值：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> accounts </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> email VARCHAR2( <span class=\"number\">100</span> ) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>但是，Oracle发出以下错误：<br><code>SQL Error: ORA-02296: cannot enable (OT.) - null values found</code><br>因为当将列从可为null改为not null时，<strong>必须确保现有数据符合新约束</strong>(也就是说，如果原来数据中NULL是不行的)。<br>为了解决这个问题，首先更新email列的值，然后改变email列的约束</p>\n<ol start=\"4\">\n<li>扩大或缩短列示例的大小<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> accounts </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> phone VARCHAR2( <span class=\"number\">24</span> );</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>要<strong>缩短</strong>列的大小，<strong>请确保列中的所有数据都符合新的大小</strong></p>\n<ol start=\"5\">\n<li><p>修改虚拟列<br> 可以更改虚拟列full_name的表达式，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> accounts </span><br><span class=\"line\"><span class=\"keyword\">MODIFY</span> full_name VARCHAR2(<span class=\"number\">52</span>) </span><br><span class=\"line\"><span class=\"keyword\">GENERATED</span> <span class=\"keyword\">ALWAYS</span> <span class=\"keyword\">AS</span> (last_name || <span class=\"string\">', '</span> || first_name);</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>修改列的默认值<br>添加一个名为status的新列，默认值为1到accounts表中。参考以下语句 -</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> accounts</span><br><span class=\"line\"><span class=\"keyword\">ADD</span> <span class=\"keyword\">status</span> <span class=\"built_in\">NUMBER</span>( <span class=\"number\">1</span>, <span class=\"number\">0</span> ) <span class=\"keyword\">DEFAULT</span> <span class=\"number\">1</span> <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> ;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>当执行了该语句，就会将accounts表中的所有现有行的status列中的值设置为1</p>\n<h4 id=\"TRUNCATE-TABLE语句\">TRUNCATE TABLE语句<a href=\"post/Oracle-基础教程#TRUNCATE-TABLE语句\"></a></h4><ol>\n<li><p>如果要从表中删除所有数据，可以使用不带WHERE子句的DELETE语句，如下所示：<br><code>DELETE FROM table_name;</code><br>对于有少量行记录的表，DELETE语句做得很好。 但是，当拥有大量行记录的表时，使用DELETE语句删除所有数据<strong>效率并不高</strong>。<br>Oracle引入了<code>TRUNCATE TABLE</code>语句，<strong>用于删除大表中的所有行</strong>。</p>\n</li>\n<li><p>TRUNCATE TABLE语句的语法：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">TRUNCATE</span> <span class=\"keyword\">TABLE</span> schema_name.table_name</span><br><span class=\"line\">[<span class=\"keyword\">CASCADE</span>]</span><br><span class=\"line\">[[ <span class=\"keyword\">PRESERVE</span> | <span class=\"keyword\">PURGE</span>] <span class=\"keyword\">MATERIALIZED</span> <span class=\"keyword\">VIEW</span> <span class=\"keyword\">LOG</span> ]]</span><br><span class=\"line\">[[ <span class=\"keyword\">DROP</span> | <span class=\"keyword\">REUSE</span>]] <span class=\"keyword\">STORAGE</span> ]</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p><code>TRUNCATE TABLE CASCADE</code>语句删除table_name表中的所有行，并递归地截断链中的关联表。</p>\n<blockquote>\n<p>请注意，<code>TRUNCATE TABLE CASCADE</code>语句需要使用<code>ON DELETE CASCADE</code>子句定义的外键约束才能工作。</p>\n</blockquote>\n<p> 通过<code>MATERIALIZED VIEW LOG</code>子句，可以指定在表上定义的物化视图日志是否在截断表时被保留或清除。 <strong>默认情况下，物化视图日志被保留</strong>。  </p>\n<p> <code>STORAGE</code>子句允许选择删除或重新使用由截断行和关联索引(如果有的话)释放的存储。 <strong>默认情况下，存储被删除</strong>。</p>\n<blockquote>\n<p>请注意，要截断表，它必须在您自己的模式中，或者必须具有DROP ANY TABLE系统权限。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"Rename表语句\">Rename表语句<a href=\"post/Oracle-基础教程#Rename表语句\"></a></h4><ol>\n<li>要重命名表，可以使用以下Oracle RENAME表语句，如下所示：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RENAME</span> table_name <span class=\"keyword\">TO</span> new_name;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在RENAME表语句中：<br>    * 首先，指定将要重命名的表名称。<br>    * 其次，指定新的表名。新名称不能与同一模式中的另一个表相同。</p>\n<pre><code>&gt; 请注意，一旦执行了RENAME语句，就**不能回滚**了。\n\n当重命名表时，Oracle自动将旧表上的索引，约束和授权转移到新表上。 另外，它使依赖重命名表(原表)的所有对象失效，如**视图，存储过程，函数和同义词**。</code></pre><h4 id=\"数据类型\">数据类型<a href=\"post/Oracle-基础教程#数据类型\"></a></h4><ol>\n<li><p>Oracle具有下表中所示的一些内置数据类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">代码</th>\n<th align=\"left\">数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">VARCHAR2(size [BYTE / CHAR])</td>\n</tr>\n<tr>\n<td align=\"left\">1</td>\n<td align=\"left\">NVARCHAR2(size)</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">NUMBER[(precision [, scale])]</td>\n</tr>\n<tr>\n<td align=\"left\">8</td>\n<td align=\"left\">LONG</td>\n</tr>\n<tr>\n<td align=\"left\">12</td>\n<td align=\"left\">DATE</td>\n</tr>\n<tr>\n<td align=\"left\">22</td>\n<td align=\"left\">BINARY_DOUBLE</td>\n</tr>\n<tr>\n<td align=\"left\">23</td>\n<td align=\"left\">RAW(size)</td>\n</tr>\n<tr>\n<td align=\"left\">34</td>\n<td align=\"left\">LONG RAW</td>\n</tr>\n<tr>\n<td align=\"left\">69</td>\n<td align=\"left\">ROWID</td>\n</tr>\n<tr>\n<td align=\"left\">96</td>\n<td align=\"left\">CHAR [(size [BYTE / CHAR])]</td>\n</tr>\n<tr>\n<td align=\"left\">96</td>\n<td align=\"left\">NCHAR[(size)]</td>\n</tr>\n<tr>\n<td align=\"left\">112</td>\n<td align=\"left\">CLOB</td>\n</tr>\n<tr>\n<td align=\"left\">112</td>\n<td align=\"left\">NCLOB</td>\n</tr>\n<tr>\n<td align=\"left\">113</td>\n<td align=\"left\">BLOB</td>\n</tr>\n<tr>\n<td align=\"left\">114</td>\n<td align=\"left\">BFILE</td>\n</tr>\n<tr>\n<td align=\"left\">180</td>\n<td align=\"left\">TIMESTAMP [(fractional_seconds)]</td>\n</tr>\n<tr>\n<td align=\"left\">181</td>\n<td align=\"left\">TIMESTAMP [(fractional_seconds)] WITH TIME ZONE</td>\n</tr>\n<tr>\n<td align=\"left\">182</td>\n<td align=\"left\">INTERVAL YEAR [(year_precision)] TO MONTH</td>\n</tr>\n<tr>\n<td align=\"left\">183</td>\n<td align=\"left\">INTERVAL DAY [(day_precision)] TO SECOND[(fractional_seconds)]</td>\n</tr>\n<tr>\n<td align=\"left\">208</td>\n<td align=\"left\">UROWID [(size)]</td>\n</tr>\n<tr>\n<td align=\"left\">231</td>\n<td align=\"left\">TIMESTAMP [(fractional_seconds)] WITH LOCAL TIMEZONE</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>每种数据类型都有由Oracle内部管理的代码。要查找列中值的数据类型代码，请使用<code>DUMP()</code>函数。</p>\n</blockquote>\n</li>\n<li><p>字符数据类型<br> 字符数据类型由:<code>CHAR</code>，<code>NCHAR</code>，<code>VARCHAR2</code>，<code>NVARCHAR2</code>和<code>VARCHAR</code>组成。<code>NCHAR</code>和<code>NVARCHAR2</code>数据类型用于存储Unicode字符串。<br> <strong>固定长度字符数据类型</strong>是<code>CHAR</code>，<code>NCHAR</code>，<strong>可变长度字符数据类型</strong>是：<code>VARCHAR2</code>和<code>NVARCHAR2</code>。<br> <strong><code>VARCHAR</code>是<code>VARCHAR2</code>的同义词</strong>。但是，<strong>不建议使用<code>VARCHAR</code></strong>，因为Oracle将来可能会更改它的语义。<br> 对于字符数据类型，可以用字节或字符指定它们的大小。</p>\n</li>\n<li><p>数字数据类型<br> <code>NUMBER</code>数据类型具有精度p和比例s。精度范围从1到38，范围从-84到127。<br> 如果不指定精度，那么该列可以存储包括定点数和浮点数的值。比例的默认值是零。</p>\n</li>\n<li><p>日期时间和时间间隔数据类型<br> 日期时间数据类型是<code>DATE</code>，<code>TIMESTAMP</code>，<code>TIMESTAMP WITH TIME ZONE</code>和<code>TIMESTAMP WITH LOCAL TIME ZONE</code>。 <strong>日期时间数据类型的值是日期时间</strong>。<br> 区间数据类型为<code>INTERVAL YEAR TO MONTH</code>和<code>INTERVAL DAY TO SECOND</code>。 <strong>区间数据类型的值是区间</strong>。</p>\n</li>\n<li><p><code>RAW</code>和<code>LONG RAW</code>数据类型<br> <code>RAW</code>和<code>LONG RAW</code>数据类型用于存储二进制数据或字节字符串，例如文档，声音文件和视频文件的内容。<br> <code>RAW</code>数据类型最多可以存储2000字节，而<code>LONG RAW</code>数据类型最多可以存储2GB。</p>\n</li>\n<li><p><code>BFILE</code>数据类型<br> BFILE数据类型将定位器存储到位于数据库之外的大型二进制文件。 定位器由目录和文件名组成。</p>\n</li>\n<li><p><code>BLOB</code>数据类型<br> <code>BLOB</code>代表二进制大对象。可以使用<code>BLOB</code>数据类型来存储最大大小为(4千兆字节 - 1)*(数据库块大小)的二进制对象。</p>\n</li>\n<li><p><code>CLOB</code>数据类型<br> <code>CLOB</code>代表字符大的对象。使用<code>CLOB</code>存储单字节或多字节字符，最大大小为(4千兆字节 - 1)*(数据库块大小)。</p>\n<blockquote>\n<p>请注意，CLOB支持固定字符集和变量字符集。</p>\n</blockquote>\n</li>\n<li><p><code>NCLOB</code>数据类型<br><code>NCLOB</code>与<code>CLOB</code>类似，不同的是它可以存储Unicode字符。</p>\n</li>\n<li><p>UROWID数据类型<br><code>UROWID</code>主要用于<code>ROWID</code>伪列返回的值。它的值是基本的64个字符串，它们表示表中行的唯一地址。</p>\n</li>\n<li><p>数据类型：Oracle和ANSI<br>将ANSI数据类型用于列定义时，Oracle将根据以下映射表将Oracle转换为其相应的数据类型：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ANSI SQL数据类型</th>\n<th align=\"left\">Oracle SQL数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CHARACTER(n), CHAR(n)</td>\n<td align=\"left\">CHAR(n)</td>\n</tr>\n<tr>\n<td align=\"left\">CHARACTER VARYING(n), CHAR VARYING(n)</td>\n<td align=\"left\">VARCHAR2(n)</td>\n</tr>\n<tr>\n<td align=\"left\">NATIONAL CHARACTER(n), NATIONAL CHAR(n), NCHAR(n)</td>\n<td align=\"left\">NCHAR(n)</td>\n</tr>\n<tr>\n<td align=\"left\">NATIONAL CHARACTER VARYING(n), NATIONAL CHAR VARYING(n), NCHAR VARYING(n)</td>\n<td align=\"left\">NVARCHAR2(n)</td>\n</tr>\n<tr>\n<td align=\"left\">NUMERIC(p,s), DECIMAL(p,s) (a)</td>\n<td align=\"left\">NUMBER(p,s)</td>\n</tr>\n<tr>\n<td align=\"left\">INTEGER, INT, SMALLINT</td>\n<td align=\"left\">NUMBER(38)</td>\n</tr>\n<tr>\n<td align=\"left\">FLOAT (b), DOUBLE PRECISION (c), REAL (d)</td>\n<td align=\"left\">NUMBER</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h4 id=\"Number数字类型\">Number数字类型<a href=\"post/Oracle-基础教程#Number数字类型\"></a></h4><ol>\n<li><code>NUMBER</code>数据类型用于存储可能为负值或正值的数值。以下说明了<code>NUMBER</code>数据类型的语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NUMBER[(precision [, scale])]</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p><code>NUMBER</code>数据类型具有以下精度和尺度。<br>    * 精度是一个数字中的位数。 范围从1到38。<br>    * 尺度是数字中小数点右侧的位数。 范围从-84到127。</p>\n<pre><code>例如，数字1234.56的精度是6，尺度是2。所以要存储这个数字，需要定义为：NUMBER(6,2)。  \n精度和尺度都是十进制数字，可选。 如果跳过精度和小数位，Oracle**使用数字的最大范围和精度。**</code></pre><ol start=\"2\">\n<li>请注意，如果在NUMBER(p，s)列中插入数字，并且<strong>数字超过精度p，则Oracle将发出错误</strong>。 但是，如果<strong>数量超过尺度s，则Oracle将对该值进行四舍五入</strong>。</li>\n<li>NUMBER数据类型别名</li>\n</ol>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th align=\"left\">ANSI数据类型</th>\n<th align=\"left\">Oracle NUMBER数据类型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">INT</td>\n<td align=\"left\">NUMBER(38)</td>\n</tr>\n<tr>\n<td align=\"left\">SMALLINT</td>\n<td align=\"left\">NUMBER(38)</td>\n</tr>\n<tr>\n<td align=\"left\">NUMBER(p,s)</td>\n<td align=\"left\">NUMBER(p,s)</td>\n</tr>\n<tr>\n<td align=\"left\">DECIMAL(p,s)</td>\n<td align=\"left\">NUMBER(p,s)</td>\n</tr>\n</tbody></table></div></div>\n<blockquote>\n<p>请注意，<code>INT</code>，<code>SMALLINT</code>，<code>NUMERIC</code>和<code>DECIMAL</code>只是别名。它们不是真正的数据类型。 Oracle在内部将这些别名映射到相应的NUMBER数据类型。</p>\n</blockquote>\n<h4 id=\"Float类型\">Float类型<a href=\"post/Oracle-基础教程#Float类型\"></a></h4><ol>\n<li><code>FLOAT</code>数据类型是<code>NUMBER</code>数据类型的子类型。 其主要目的是促进与<code>ANSI SQL FLOAT</code>数据类型的兼容。</li>\n<li>以下显示<code>FLOAT</code>数据类型的语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FLOAT(p)</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>我们只能指定<code>FLOAT</code>数据类型的精度。不能指定尺度，因为Oracle数据库从数据中解析尺度的。 <code>FLOAT</code>的最大精度是126。</p>\n<ol start=\"3\">\n<li>在<code>FLOAT</code>中，精度是二进制位，而在<code>NUMBER</code>中精度是十进制数。可以使用以下公式在二进制和十进制精度之间进行转换：<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P(d) = 0.30103 * P(b)</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>根据这个公式，因二进制精度的最大126位数，<strong>大致等于十进制数位数的38位数</strong>。</p>\n<ol start=\"4\">\n<li><p>为了使它与<code>SQL ANSI FLOAT</code>兼容，Oracle提供了一些别名，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">ANSI SQL FLOAT</th>\n<th align=\"left\">Oracle FLOAT</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">FLOAT</td>\n<td align=\"left\">FLOAT(126)</td>\n</tr>\n<tr>\n<td align=\"left\">REAL</td>\n<td align=\"left\">FLOAT(63)</td>\n</tr>\n<tr>\n<td align=\"left\">DOUBLE PRECISION</td>\n<td align=\"left\">FLOAT(126)</td>\n</tr>\n</tbody></table>\n<p> 例如，不使用<code>FLOAT(63)</code>数据类型，可以使用<code>REAL</code>别名代替。</p>\n</li>\n</ol>\n<h4 id=\"Char类型\">Char类型<a href=\"post/Oracle-基础教程#Char类型\"></a></h4><ol>\n<li><code>CHAR</code>数据类型用于存储<strong>固定长度</strong>的字符串。 CHAR数据类型可以存储1到2000字节的字符串。</li>\n<li>要定义一个<code>CHAR</code>列，需要用字节或字符来指定一个字符串长度，如下所示：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CHAR(length BYTE)</span><br><span class=\"line\">CHAR(length CHAR)</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>如果没有明确指定BYTE或CHAR，那么Oracle会默认使用<code>BYTE</code>。<br>如果像下面的例子那样不指定长度，那么<strong>长度的默认值是1</strong>。</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">column_name CHAR</span><br></pre></td></tr></table></div></figure>\n\n<p>插入或更新固定长度字符串列时，Oracle将字符存储为固定长度数据。 这意味着如果存储的值的长度小于列中定义的最大长度，则Oracle<strong>将空格填充到最大长度的字符串</strong>。 <strong>如果插入一个长度大于列的值，Oracle会返回一个错误</strong>。</p>\n<pre><code>&gt; **Oracle使用空格填充后来比较CHAR值**。</code></pre><ol start=\"3\">\n<li>在比较长度不等的字符类型的字符串时，Oracle使用非空格字符填充语义。<br>要使其工作，需要使用<code>RTRIM()</code>函数从<code>CHAR</code>数据中去除空格，然后将其与输入字符串进行比较</li>\n</ol>\n<h4 id=\"NChar类型\">NChar类型<a href=\"post/Oracle-基础教程#NChar类型\"></a></h4><ol>\n<li><code>NCHAR</code>数据类型用于存储<strong>固定长度的Unicode字符数据</strong>。<code>NCHAR</code>的字符集只能是AL16UTF16或UTF8，在数据库创建时<strong>指定为国家字符集</strong>。</li>\n<li>当使用NCHAR列创建表时，NCHAR列的最大大小始终在字符长度语义中，例如：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> nchar_demo (</span><br><span class=\"line\">    description <span class=\"keyword\">NCHAR</span>(<span class=\"number\">10</span>)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在本例中，description列的最大长度是10个字符。对于NCHAR列的最大大小，不可能使用字节长度，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">description NCHAR(10 BYTE) <span class=\"comment\">-- not possible</span></span><br></pre></td></tr></table></div></figure>\n\n<p>NCHAR列的最大字节长度取决于当前的国家字符集。 它是每个字符中<strong>最大字符长度和最大字节数的乘积</strong>。<br>要查找当前的国家字符集，请使用以下语句：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    nls_database_parameters</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    PARAMETER = <span class=\"string\">'NLS_NCHAR_CHARACTERSET'</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p><code>AL16UTF16</code>字符集使用2个字节存储一个字符，所以description列的最大字节长度为20个字节。  </p>\n<blockquote>\n<p>Oracle将NCHAR列的<strong>最大长度限制为2000字节</strong>。 这意味着一个NCHAR列只能容纳2000字符的1字节字符或1000个字符的2字节字符。</p>\n</blockquote>\n<ol start=\"3\">\n<li>NCHAR与CHAR比较/区别<br>首先，<code>NCHAR</code>的最大长度<strong>只在字符长度语义上</strong>，而<code>CHAR</code>的最大长度可以是<strong>字符长度或字节长度语义</strong>。<br>其次，<code>NCHAR</code>将字符存储在国家默认字符集中，而<code>CHAR</code>将字符存储在默认字符集中。<br>以下语句返回由CHAR使用的默认字符集和由NCHAR使用的默认国家字符集：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    *</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    nls_database_parameters</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    PARAMETER <span class=\"keyword\">IN</span>(</span><br><span class=\"line\">        <span class=\"string\">'NLS_CHARACTERSET'</span>,</span><br><span class=\"line\">        <span class=\"string\">'NLS_NCHAR_CHARACTERSET'</span></span><br><span class=\"line\">    );</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<h4 id=\"Varchar2类型\">Varchar2类型<a href=\"post/Oracle-基础教程#Varchar2类型\"></a></h4><ol>\n<li>要存储可变长度的字符串，可以使用<code>VARCHAR2</code>数据类型。 <code>VARCHAR2</code>列可以存储1到4000字节的值。 这意味着对于单字节字符集，<strong>最多可以在<code>VARCHAR2</code>列中存储4000个字符</strong>。</li>\n<li>当使用VARCHAR2列创建表时，<strong>必须指定最大字符串长度(以字节为单位)</strong>：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VARCHAR2(max_size BYTE)</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>或以字符</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">VARCHAR2(max_size CHAR)</span><br></pre></td></tr></table></div></figure>\n\n<p>默认情况下，<strong>如果没有在max_size之后显式指定BYTE或CHAR，则Oracle使用BYTE</strong>。 换句话说，VARCHAR2(N)列最多可以容纳N个字节的字符。<br>如果存储大小超过<code>VARCHAR2</code>列最大长度的字符串，则Oracle发出错误。</p>\n<ol start=\"2\">\n<li>如果在<code>VARCHAR2(20)</code>列中存储10个字符，则Oracle仅使用10个字节进行存储，而不是20个字节。 因此，使用<code>VARCHAR2</code>数据类型可以帮助您节省表使用的空间。  </li>\n</ol>\n<p><strong>比较<code>VARCHAR2</code>值时，Oracle使用非填充比较语义</strong>。</p>\n<ol start=\"3\">\n<li>从Oracle 12c开始，可以为<code>VARCHAR2</code>数据类型最大长度为：32767。 Oracle使用<code>MAX_STRING_SIZE</code>参数来控制最大长度。 如果<code>MAX_STRING_SIZE</code>是<code>STANDARD</code>，则<code>VARCHAR2</code>的最大大小是4000字节。 如果<code>MAX_STRING_SIZE</code>为<code>EXTENDED</code>，则<code>VARCHAR2</code>的大小限制为32767。<br>要获取<code>MAX_STRING_SIZE</code>参数的值，请使用以下查询：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">    <span class=\"keyword\">name</span>,</span><br><span class=\"line\">    <span class=\"keyword\">value</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">    v$parameter</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">    <span class=\"keyword\">name</span> = <span class=\"string\">'max_string_size'</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<h4 id=\"Date类型\">Date类型<a href=\"post/Oracle-基础教程#Date类型\"></a></h4><ol>\n<li><code>DATE</code>数据类型允许以一秒的精度存储包括日期和时间的时间点值。<br><code>DATE</code>数据类型存储年份(包括世纪)，月份，日期，小时数，分钟数和秒数。 它的范围从公元前4712年1月1日到公元9999年12月31日(共同时代)。 默认情况下，如果未明确使用BCE，则Oracle使用CE日期条目。</li>\n<li>Oracle数据库有其自己的专用格式来存储日期数据。它<strong>使用7个字节的固定长度的字段</strong>，每个字段对应于世纪，年，月，日，时，分和秒来存储日期数据。</li>\n<li>Oracle日期格式<br>输入和输出的标准日期格式是<code>DD-MON-YY</code>，例如由<code>NLS_DATE_FORMAT</code>参数的值表示为：<br><code>01-JAN-17</code>。<br>以下语句显示了NLS_DATE_FORMAT参数的当前值：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">  <span class=\"keyword\">value</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">  V$NLS_PARAMETERS</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span></span><br><span class=\"line\">  parameter = <span class=\"string\">'NLS_DATE_FORMAT'</span>;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>在Oracle数据库系统中，NLS_DATE_FORMAT的值是：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DD-MON-RR</span><br></pre></td></tr></table></div></figure>\n\n<p>以下语句通过使用SYSDATE函数以标准日期格式返回当前日期。</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">  <span class=\"keyword\">sysdate</span></span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">  dual;</span><br></pre></td></tr></table></div></figure>\n\n<ol start=\"4\">\n<li><p>假设想要将标准日期格式更改为<code>YYYY-MM-DD</code>，那么可以使用<code>ALTER SESSION</code>语句来更改<code>NLS_DATE_FORMAT</code>参数的值，如下所示：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">SESSION</span> <span class=\"keyword\">SET</span> NLS_DATE_FORMAT = <span class=\"string\">'YYYY-MM-DD'</span>;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>使用<code>TO_CHAR()</code>函数格式化日期<br><code>TO_CHAR()</code>函数采用DATE值作为参数，根据指定的格式对其进行格式化，并返回一个日期字符串。<br>例如，要以特定的格式显示当前的系统日期，请按如下所示使用<code>TO_CHAR()</code>函数：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">  TO_CHAR( <span class=\"keyword\">SYSDATE</span>, <span class=\"string\">'MM/DD/YYYY'</span> )</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">  dual;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>将字符串转换为日期<br>由于Oracle使用内部格式来存储DATE数据，因此在将日期值存储到日期列之前，通常必须将字符串转换为日期值。<br>要转换不是标准格式的日期值，可以使用带有格式字符串的<code>TO_DATE()</code>函数。<br>以下示例使用TO_DATE()函数将字符串“August 01，2017”转换为相应的日期：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">-- alter session set nls_language='SIMPLIFIED CHINESE';</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span></span><br><span class=\"line\">  <span class=\"keyword\">TO_DATE</span>(<span class=\"string\">'2018-10-21'</span>, <span class=\"string\">'YYYY-MM-DD'</span> )</span><br><span class=\"line\"><span class=\"keyword\">FROM</span></span><br><span class=\"line\">  dual;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>日期文字<br>除了使用TO_DATE()函数之外，还可以使用以下语法将日期值指定为字符串文字：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATE 'YYYY-MM-DD'</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>请注意，要使用日期作为文字，必须使用公历。 以下示例显示2017年8月1日的ANSI日期字面值：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DATE '2017-08-01'</span><br></pre></td></tr></table></div></figure>\n\n<p>ANSI日期文字没有时间部分，<strong>必须采用确切格式(‘YYYY-MM-DD’)</strong>。 如果要将时间数据包含在日期值中，则必须使用上面介绍的<code>TO_DATE()</code>函数。</p>\n<h4 id=\"Timestamp类型\">Timestamp类型<a href=\"post/Oracle-基础教程#Timestamp类型\"></a></h4><ol>\n<li><code>TIMESTAMP</code>数据类型用于存储日期和时间数据，包括年，月，日，时，分和秒。<br>另外，它存储小数秒，它不是由<code>DATE</code>数据类型存储的。<br>要定义TIMESTAMP列，请使用以下语法：<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">column_name TIMESTAMP[(fractional_seconds_precision)]</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p><code>fractional_seconds_precision</code>指定SECOND字段小数部分的位数。它的范围从0到9，这意味着可以使用<code>TIMESTAMP</code>数据类型来存储到纳秒的精度。<br>如果省略<code>fractional_seconds_precision</code>，则默认为6。  以下表达式说明了如何定义TIMESTAMP列：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">started_at TMESTAMP(6),</span><br><span class=\"line\">...</span><br></pre></td></tr></table></div></figure>\n\n<p>在此示例中，started_at列是一个TIMESTAMP列，其分数秒精度设置为微秒。</p>\n<ol start=\"2\">\n<li><p>TIMESTAMP文字<br> 要指定TIMESTAMP文字，请使用以下格式：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF'</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>格式化TIMESTAMP值<br> 要更改TIMESTAMP值的输出，可以使用<code>TO_CHAR()</code>函数，将TIMESTAMP值或列的名称作为第一个参数，将格式字符串作为第二个参数。  </p>\n<p> 以下语句使用<code>TO_CHAR()</code>函数来格式化logged_at列中的值：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> message,</span><br><span class=\"line\">    TO_CHAR(logged_at, <span class=\"string\">'MONTH DD, YYYY \"at\" HH24:MI'</span>)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> <span class=\"keyword\">logs</span>;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>提取TIMESTAMP组件<br> 要提取TIMESTAMP组件(如年，月，日，小时，分钟和秒)，请<strong>使用<code>EXTRACT()</code>函数</strong>：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EXTRACT( component FROM timestamp);</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<h4 id=\"Interval类型\">Interval类型<a href=\"post/Oracle-基础教程#Interval类型\"></a></h4><ol>\n<li><p>Oracle提供了两种日期时间数据类型：DATE和TIMESTAMP用于存储时间点数据。另外，它提供<code>INTERVAL</code>数据类型用于存储一段时间。<br>有两种类型的<code>INTERVAL</code>：</p>\n<ul>\n<li><code>INTERVAL YEAR TO MONTH</code> - 间隔使用年份和月份。</li>\n<li><code>INTERVAL DAY TO SECOND</code> - 使用包括小数秒在内的天，小时，分钟和秒存储间隔。</li>\n</ul>\n</li>\n<li><p>INTERVAL YEAR TO MONTH<br> <code>INTERVAL YEAR TO MONTH</code>数据类型使用YEAR和MONTH字段存储一段时间。<br> 下面介绍一个<code>INTERVAL YEAR TO MONTH</code>：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INTERVAL YEAR [(year_precision)] TO MONTH</span><br></pre></td></tr></table></div></figure>\n\n<p> <code>year_precision</code>代表YEAR字段中的位数。范围从0到9。<br> <code>year_precision</code>是可选的。如果省略<code>year_precision</code>参数，则默认为2。也就是说，默认情况下，最多可以存储99年和11个月的期限，这个期限<strong>必须小于100年</strong>。</p>\n</li>\n<li><p>INTERVAL YEAR TO MONTH文字<br> 要指定<code>INTERVAL YEAR TO MONTH</code>数据类型的文字值，可以使用以下格式：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INTERVAL 'year[-month]' leading (precision) TO trailing</span><br></pre></td></tr></table></div></figure>\n\n<p> leading和trailing可以是YEAR或MONTH。<br> 以下是参数：</p>\n<ul>\n<li>year[-month]<br>year和month是整个区间的leading和trailing的整数。 如果leading是YEAR，trailing是MONTH，那么month字段的范围从0到11。<br><strong>trailing列必须小于leading列</strong>。 例如，INTERVAL ‘1-2’ MONTH TO YEAR是无效的，因为leading列YEAR大于MONTH的leading字段。</li>\n<li>precision<br>是leading字段中的最大数字位数。精度范围为:0~9，默认值为2。</li>\n</ul>\n</li>\n<li><p>下表说明了<code>INTERVAL YEAR TO MONTH</code>文字的示例：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">INTERVAL YEAR TO MONTH文字</th>\n<th align=\"left\">含意</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">INTERVAL ‘120-3’ YEAR(3) TO MONTH</td>\n<td align=\"left\">间隔120年，3个月; 由于前导字段的值大于默认精度(2位)，因此必须指定前导字段精度YEAR(3)。</td>\n</tr>\n<tr>\n<td align=\"left\">INTERVAL ‘105’ YEAR(3)</td>\n<td align=\"left\">间隔105年0个月。</td>\n</tr>\n<tr>\n<td align=\"left\">INTERVAL ‘500’ MONTH(3)</td>\n<td align=\"left\">间隔500个月。</td>\n</tr>\n<tr>\n<td align=\"left\">INTERVAL ‘9’ YEAR</td>\n<td align=\"left\">间隔9年，相当于INTERVAL ‘9-0’ YEAR TO MONTH</td>\n</tr>\n<tr>\n<td align=\"left\">INTERVAL ‘40’ MONTH</td>\n<td align=\"left\">40个月或3年4个月，相当于INTERVAL ‘3-4’ YEAR TO MONTH</td>\n</tr>\n<tr>\n<td align=\"left\">INTERVAL ‘180’ YEAR</td>\n<td align=\"left\">无效的时间间隔，因为’180’有3个数字，它大于默认精度(2)</td>\n</tr>\n</tbody></table>\n</li>\n<li><p><code>INTERVAL DAY TO SECOND</code>数据类型<br> <code>INTERVAL DAY TO SECOND</code>是一种按天，小时，分钟和秒钟存储一段时间。<br> 以下显示<code>INTERVAL DAY TO SECOND</code>数据类型的语法：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]</span><br></pre></td></tr></table></div></figure>\n\n<p> 在上面这个语法中，<br> <code>day_precision</code> - 是DAY字段中的位数。取值范围是0<del>9，缺省值是2。<br> <code>fractional_seconds_precision</code> 是SECOND字段小数部分的位数。范围从0</del>9。如果省略<code>fractional_seconds_precision</code>，则默认为6。</p>\n</li>\n</ol>\n<h4 id=\"Oracle主键\">Oracle主键<a href=\"post/Oracle-基础教程#Oracle主键\"></a></h4><ol>\n<li><p>主键是表中列的唯一标识表中的行的<strong>一列或多列的组合</strong>。<br>以下是设置列成为主键的规则：</p>\n<ul>\n<li><strong>主键列不能包含NULL值或空字符串</strong>。</li>\n<li>主键值在整个表中必须是唯一的。</li>\n<li>主键值不应随时间而改变。</li>\n</ul>\n</li>\n<li><p>根据1中这些规则，以下是对主键的建议：</p>\n<ul>\n<li><p>首先，主键应该是没有意义的。 有时，您可能需要使用有意义的数据，例如：社会安全号码(SSN)，车辆识别号码(VIN)，电子邮件和电话号码等，这些数据被认为是唯一的。 但是，您不知道电子邮件或电话号码何时更改或被他人重复使用。 在这种情况下，会造成很多数据问题。</p>\n</li>\n<li><p>其次，主键应该是紧凑的。主键通常是数字的，因为<strong>Oracle通常处理数字的速度比任何其他数据类型更快</strong>。</p>\n<blockquote>\n<p>注意：尽管在Oracle中不是强制性的，但在每个表中都有一个主键是最佳实践。</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p>通常，在创建表时创建表的主键。另外，通过使用<code>ALTER TABLE</code>语句，可以在创建表之后再添加一个主键。</p>\n</li>\n<li><p>删除Oracle PRIMARY KEY约束<br>一般很少会从表中删除PRIMARY KEY约束。 如果必须要删除主键，则使用以下ALTER TABLE语句。</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> primary_key_constraint_name;</span><br></pre></td></tr></table></div></figure>\n</li>\n<li><p>启用/禁用Oracle PRIMARY KEY约束<br>要在将大量数据加载到表中或更新海量数据时需要<strong>提高性能</strong>，可以暂时禁用PRIMARY KEY约束。<br>要禁用表的主键约束，可以使用ALTER TABLE语句：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">DISABLE</span> <span class=\"keyword\">CONSTRAINT</span> primary_key_constraint_name;</span><br></pre></td></tr></table></div></figure>\n\n</li>\n</ol>\n<p>或者，</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">DISABLE</span> PRIMARY <span class=\"keyword\">KEY</span>;</span><br></pre></td></tr></table></div></figure>\n\n<p>要启用主键约束，请使用以下ALTER TABLE语句：</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">ENABLE</span> <span class=\"keyword\">CONSTRAINT</span> primary_key_constraint_name;</span><br></pre></td></tr></table></div></figure>\n\n<p>或者，</p>\n<figure class=\"highlight sql\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">ENABLE</span> PRIMARY <span class=\"keyword\">KEY</span>;</span><br></pre></td></tr></table></div></figure>","prev":{"title":"Oracle-函数","link":"post/Oracle-函数"},"next":{"title":"Oracle-执行顺序","link":"post/Oracle-执行顺序"},"plink":"http://ZhongJinMing.github.io/post/Oracle-基础教程/","toc":[{"title":"Oracle基础","id":"Oracle基础","index":"1"}]}