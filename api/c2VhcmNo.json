[{"title":"H5学习笔记","date":"2019-08-24T07:04:41.000Z","updated":"2019-08-24T08:57:00.621Z","content":"一、语法\nundefined是一个尚未赋值的变量的值\n删除数组元素的方法：将该索引的数组元素设置为null;使用函数splice，所删除元素后面的所有元素的索引都减1;\nnull表示这个变量有一个空值\nMath.random会返回一个介于0和1的浮点数（但是不会为1）\nMath.floor把一个浮点数小数点后面的所有位去除，把它转换为一个整数\n文本输入域可以包含一个空串””\nattribute和property的区别\n如果注册了一个按钮点击事件处理程序，点击这个按钮时就会调用这个函数\n\n二、Javascript函数和对象\n函数会为你完成实例化变量的全部工作，所以你不需要在形参名前面加var关键字\n\n如果没有一个return语句，这样的函数会返回undefined\n\n要尽可能减少或消除全局变量\n\n如果不同文件中有两个同名的函数，将使用浏览器最后看到的那个函数\n\n1234var f = function(num) &#123;return num + 1;&#125;// 在这里将一个匿名函数赋值给了变量f\n\n利用点操作符(.)可以访问一个对象的属性。一般来讲，这种记法比[&quot;string&quot;]记法更易读\n\ndelete可删除一个属性\n\n根据约定，如果对象有一个函数，我们就称它是一个方法。可以认为函数是一段能调用的独立代码，而方法是与一个特定对象关联的行为\n\nthis是一个关键字，而不是一个变量\n\n如果没有调用一个对象方法，this就是未定义的(undefined)\n\n用大括号和逗号分隔的属性所写的对象称为“对象字面量”\n\n\n\n\n\n\nwindow\n\n\n\nlocation\n\n\nstatus\n\n\nonload\n\n\ndocument\n\n\nalert\n\n\nprompt\n\n\nopen\n\n\nclose\n\n\nsetTimeout\n\n\nsetInterval\n\n\n\n\n\n\n元素对象\n\n\n\ninnerHTML\n\n\nchildElementCount\n\n\nfirstChild\n\n\nappendChild\n\n\ninsertBefore\n\n\nsetAttribute\n\n\ngetAttribute\n\n\n\n\n\n\n\n\ndocument\n\n\n\ndomain\n\n\ntitle\n\n\nURL\n\n\ngetElementById\n\n\ngetElementsByTagName\n\n\ngetElementsByClassName\n\n\ncreateElement\n\n\n\n传递一个对象作为一个函数的实参时，比如dog,形参会得到这个对象引用的一个副本\n可以使用点记法或[]记法访问对象的属性\n如果使用[]记法，要把属性名作为一个串用引号引起来，例如myObject[&quot;name&quot;]\n\n三、实现HTML位置感知——地理地位\n将度/分/秒转换为小数，使用下面的函数\n123function degreesToDecimal(degrees, minutes, seconds) &#123;\treturn degrees + (minutes / 60.0) + (seconds / 3600.0);&#125;\n\n西经和南纬都用负数值表示\n\nAPI就是带属性和方法的对象\n\n\n四、喜欢社交的应用\nopen只是用一个URL建立一个请求，并告诉这个请求对象要使用哪种请求，以便XMLHttpRequest验证连接，可以使用如下方法：\n12var request = new XMLHttpRequest();request.open(\"GET\", url);\n\n浏览器从远程web服务得到一个回答时，它会调用这个函数\n12345request.onload = function() &#123;\tif (request.status == 200) &#123;\t\talert(\"Data received!\");\t&#125;&#125;\n\n\n\n处理程序首先需要检查返回码是否为200或“OK”，然后可以对这个数据做任何处理。\n\n最后一步：需要告诉请求对象去获取数据，为此要使用send方法：\n12request.send(null); //这会把请求发送到服务器。如果不打算向远程服务发送任何数据，就要传入null\n\nLevel1中没有request.onload属性，所以应当使用onreadystatechange属性\n12345request.onreadystatechange = function() &#123;\tif (request.readyState == 4 &amp;&amp; request.status == 200) &#123;\t\t...\t&#125;&#125;\n\n\n\n如果readyState为4，可以知道数据已经加载\n\n浏览器不允许你对原先提供页面的域以外的其他域发出XMLHttpRequest请求\nJSONP是一种使用&lt;script&gt;标记获取JSON对象的方法。这也是一种获取数据的方法（同样的，采用JOSN对象的形式），它可以避免XMLHttpRequest的同源安全问题。\n如果你反复地获取同一个URL（比如我们的JSONP请求就是这样），浏览器为了提高效率会把它缓存起来，所以你会反复地得到同样的缓存文件\n将JSON数据包装在JSONP中的函数调用称为“回调”\n将回调函数指定为JSONP请求中的一个URL查询参数\n\n五、画布\n画布是透明的，利用画布，能够在页面上的任何位置增加图片\n\n不要在CSS中缩放画布\n\n每个选项列表都会转换为一个数组，各个选项会按顺序放在这个数组中，selectedIndex属性会返回你在下拉菜单中所选选项的编号，使用索引得到数组中的元素，这会返回一个选项对象\n\n弧度转换函数\n123function degreesToRadians(degrees) &#123;\treturn (degrees * Math.PI)/180;&#125;\n\n画布中的所有一切都认为是表现，而不是内容\n\n绘制矩形：context.fillRect创建矩形轮廓：strokeRect使用fillStyle和strokeStyle可以改变默认的填充和笔划颜色，默认颜色为黑色\n\n\n六、Vedio\n可以使用addEventListener(DOM2)方法来增加一个事件处理程序\nvar elementArray = document.querySelectorAll(&quot;selector&quot;)\n通过在一个缓冲区中处理一个视频帧，然后把它完全复制到显示画布，可以尽量减少视觉问题\n视频支持播放、暂停、加载、循环和静音方法及属性来直接控制视频的播放\n可以利用ended事件了解视频播放何时结束\n可以使用一个scratch缓冲区，在将视频复制到显示表面之前先对视频进行处理\n可以使用setTimeout处理程序来处理视频帧。尽管没有直接链接到视频的每一帧，但这是目前最好的方法\n\n七、本地存储\n一个域的所有页面会看到这个域中其他页面存储的各个数据项。\n每个浏览器会维护它自己的本地存储。如果你在Safari中创建了即时贴，就只能在Safari中看到它们\n\n八、WEB工作线程\n工作线程生活中一个相当受限的世界中。它们无法访问主浏览器代码能够访问的很多运行时对象，如DOM或主代码中的所有变量或函数\n\n工作线程做出的任何修改都不会影响主页面中的对象。工作线程在另一个环境中运行，这与主页面所在的环境不同，所以不能访问主页面所在环境中的对象。工作线程发出的对象也是如此，主页面只能得到工作线程所发送对象的一个副本\n\n工作线程可以访问localStorage，也可以做出XMLHttpRequest请求\n\nWeb工作线程有一个全局函数，名为importScripts，可以使用这个函数向工作线程导入一个或多个JavaScript文件。使用importScripts时，要向它提供你想导入的文件后URL的一个列表（各个URL之间用逗号分割），如下：\n1importScripts(\"http://bigscience.org/nuclear.js\", \"http://nasa.gov/rocket.js\", \"mylibs/atomsmasher.js\");\n\n调用importScripts时，会按顺序获取和执行各个JavaScript URL注意importScripts是一个“货真价实”的函数，所以（不同于很多语言中的import语句），可以在运行时决定如何导入，如下：\n123if (taskType == \"songdetection\") &#123;importScripts(\"audio.js\");&#125;\n\n","plink":"http://ZhongJinMing.github.io/post/H5学习笔记/"},{"title":"方案","date":"2019-08-24T05:55:08.000Z","updated":"2019-08-24T05:55:08.175Z","content":"","plink":"http://ZhongJinMing.github.io/post/方案/"},{"title":"Oracle-事务","date":"2019-08-13T10:07:37.000Z","updated":"2019-08-16T05:16:50.845Z","content":"概念\n什么是事务在数据库中事务是工作的逻辑单元，一个事务是由一个或多个完成一组的相关行为的SQL语句组成，通过事务机制确保这一组SQL语句所作的操作要么都成功执行，完成整个工作单元操作，要么一个也不执行。\n\n事务特性SQL92标准定义了数据库事务的四个特点：\n\n原子性(Atomicity)：一个事务里面所有包含的SQL语句是一个执行整体，不可分割，要么都做，要么都不做。\n一致性(Consistency)：事务开始时，数据库中的数据是一致的，事务结束时，数据库的数据也应该是一致的。\n隔离性(Isolation)：是指数据库允许多个并发事务同时对其中的数据进行读写和修改的能力，隔离性可以防止事务的并发执行时，由于他们的操作命令交叉执行而导致的数据不一致状态。\n\n\n\n\n持久性 (Durability) : 是指当事务结束后，它对数据库中的影响是永久的，即便系统遇到故障的情况下，数据也不会丢失。\n  一组SQL语句操作要成为事务，数据库管理系统必须保证这组操作的原子性（Atomicity）、一致性（consistency）、隔离性（Isolation）和持久性（Durability），这就是ACID特性。\n\n\n提交事务（COMMIT语句）\n语句Oracle / PLSQL中COMMIT语句的语法是：\n 1COMMIT [ WORK ] [ COMMENT clause ] [ WRITE clause ] [ FORCE clause ];\n\n参数    \n\nWORK - 可选的。它被Oracle添加为符合SQL标准。使用或不使用WORK参数来执行COMMIT    将产生相同的结果。\n\nCOMMENT clause - 可选的。 它用于指定与当前事务关联的注释。     * 该注释最多可以包含在单引号中的255个字节的文本中。 如果出现问题，它将与事务ID一起存储在名为* DBA_2PC_PENDING的系统视图中。\n\nWRITE clause - 可选的。 它用于指定将已提交事务的重做信息写入重做日志的优先级。     用这个子句，有两个参数可以指定：\n\nWAIT 或 NOWAIT (如果省略，WAIT是默认值)\nIMMEDIATE或BATCH(IMMEDIATE是省略时的默认值)\n\n\nFORCE clause - 可选的。 它用于强制提交可能已损坏或有疑问的事务。     * 有了这个子句，可以用3种方式指定FORCE：\n\nFORCE&#39;string&#39;，[integer]或FORCE CORRUPT_XID&#39;string&#39;或FORCE CORRUPT_XID_ALL\n注意：  必须拥有DBA权限才能访问系统视图 - DBA_2PC_PENDING和V$CORRUPT_XID_LIST。  必须拥有DBA权限才能指定COMMIT语句的某些功能。\n\n\n\n\n回滚事务（ROLLBACK语句）\n在Oracle中，ROLLBACK语句用于撤销当前事务或有问题的事务所执行的工作。\n\n语法ROLLBACK语句的语法是：\n 1ROLLBACK [ WORK ] [ TO [SAVEPOINT] savepoint_name  | FORCE 'string' ];\n\n参数   \n\nWORK - 可选的。 它被Oracle添加为符合SQL标准。 使用或不使用WORK参数来发出ROLLBACK会导致相同的结果。\nTO SAVEPOINT savepoint_name - 可选的。     ROLLBACK语句撤消当前会话的所有更改，直到由savepoint_name指定的保存点。 如果省略该子句，则所有更改都将被撤消。\nFORCE ‘string’ - 可选的。它用于强制回滚可能已损坏或有问题的事务。 使用此子句，可以将单引号中的事务ID指定为字符串。 可以在系统视图中找到名为DBA_2PC_PENDING的事务标识。\n必须拥有DBA权限才能访问系统视图 - DBA_2PC_PENDING和V$CORRUPT_XID_LIST。\n您无法将有问题的事务回滚到保存点。\n\n\n\n设置事务（SET TRANSACTION语句）\n在Oracle中，SET TRANSACTION语句用于将事务设置为只读，将事务设置为读/写，设置事务的隔离级别，为事务分配名称或将事务分配回滚段。\n\n语法 Oracle / PLSQL中SET TRANSACTION语句的语法是：\n1234SET TRANSACTION [ READ ONLY | READ WRITE ]             [ ISOLATION LEVEL [ SERIALIZE | READ COMMITED ]]             [ USE ROLLBACK SEGMENT 'segment_name' ]             [ NAME 'transaction_name' ];\n\n参数\n\nREAD ONLY - 可选的。 如果指定，它将事务设置为只读事务。\nREAD WRITE - 可选的。 如果指定，它将事务设置为读/写事务。\nISOLATION LEVEL - 可选的。 如果指定，它有两个选项：\nISOLATION LEVEL SERIALIZE - 如果事务尝试更新由另一个事务更新并未提交的资源，则事务将失败。\nISOLATION LEVEL READ COMMITTED - 如果事务需要另一个事务持有的行锁，则事务将等待，直到行锁被释放。\n\n\nUSE ROLLBACK SEGMENT - 可选的。 如果指定，它将事务分配给由&#39;segment_name&#39;标识的回退段，该段是用引号括起来的段名称。\nNAME - 为&#39;transaction_name&#39;标识的事务分配一个名称，该事务用引号括起来。\n\n\n\n锁表（LOCK TABLE语句）\nLOCK TABLE语句用于锁定表，表分区或表子分区。\n\n语法LOCK TABLE语句的语法是：\n 1LOCK TABLE tables IN lock_mode MODE [ WAIT [, integer] | NOWAIT ];\n\n参数\n\n\n\ntables - 用逗号分隔的表格列表。\nlock_mode - 它是以下值之一\n\n\n\n\nlock_mode\n描述\n\n\n\nROW SHARE\n允许同时访问表，但阻止用户锁定整个表以进行独占访问。\n\n\nROW EXCLUSIVE\n允许对表进行并发访问，但阻止用户以独占访问方式锁定整个表并以共享方式锁定表。\n\n\nSHARE UPDATE\n允许同时访问表，但阻止用户锁定整个表以进行独占访问。\n\n\nSHARE\n允许并发查询，但用户无法更新锁定的表。\n\n\nSHARE ROW EXCLUSIVE\n用户可以查看表中的记录，但是无法更新表或锁定SHARE表中的表。\n\n\nEXCLUSIVE\n允许查询锁定的表格，但不能进行其他活动。\n\n\n\nWAIT - 它指定数据库将等待(达到指定整数的特定秒数)以获取DML锁定。\nNOWAIT - 它指定数据库不应该等待释放锁。\n\n","plink":"http://ZhongJinMing.github.io/post/Oracle-事务/"},{"title":"Oracle-函数","date":"2019-08-13T10:06:37.000Z","updated":"2019-08-16T05:09:06.729Z","content":"Ascii()函数\nOracle / PLSQL ASCII()函数返回代表指定字符的数字值代码。\n语法 Oracle / PLSQL中ASCII()函数的语法是：\n 1ASCII( single_character )\n\n参数\nsingle_character - 指定的字符来检索NUMBER代码。 如果输入多个字符，则ASCII函数将返回第一个字符的值，并忽略第一个字符后的所有字符。\n返回值\nASCII函数返回一个数值。\n\n\n\n\nAsciistr()函数\nOracle / PLSQL ASCIISTR()函数使用数据库字符集将任何字符集中的字符串转换为ASCII字符串。\n语法 Oracle / PLSQL中ASCIISTR()函数的语法是：\n 1ASCIISTR( string )\n\n参数\nstring - 任何字符集中的字符串，希望将其转换为数据库字符集中的ASCII字符串s。返回值\n返回一个字符串值。适用于ASCIISTR()函数可用于以下版本的Oracle / PLSQL：Oracle 12c, Oracle 11g, Oracle 10g, Oracle 9i\n\n\n\nChr()函数\nOracle / PLSQL Chr()函数与ASCII函数的功能相反。 它根据数字代码返回字符。\n语法 Oracle / PLSQL中Chr()函数的语法是：\n 1CHR( number_code )\n\n参数\nnumber_code - 用于检索对应字符的NUMBER代码。\n返回值\n返回一个字符串值。\n\n\n\n\n","plink":"http://ZhongJinMing.github.io/post/Oracle-函数/"},{"title":"Oracle-基础教程","date":"2019-08-13T10:01:54.000Z","updated":"2019-08-16T05:09:23.446Z","content":"SELECT语句\n语法：\n123456SELECT  column_1,   column_2,   ...FROM  table_name;\n\n请注意，只能使用星号(*)进行测试。 在实践中，即使想要从表的所有列中检索数据，也应该明确指定要从中查询数据的列。这是因为业务变化，表格未来可能会有更多或更少的列。 如果在应用程序代码中使用星号(*)，并假定该表有一组固定的列，但应用程序可能不处理其他不相关的列或访问已删除的列。\n\n\nORDER BY子句\n在Oracle中，表中是以非指定顺序存储行数据记录的，它不管行插入数据库的顺序如何。要按列以升序或降序查询行记录，必须明确指示Oracle数据库要如何去排序。\n\n语法：\n12345678910SELECT    column_1,    column_2,    column_3,    ...FROM    table_nameORDER BY    column_1 [ASC | DESC] [NULLS FIRST | NULLS LAST],    column_1 [ASC | DESC] [NULLS FIRST | NULLS LAST],\n\nNULLS FIRST在非NULL值之前放置NULL值，NULLS LAST在非NULL值之后放置NULL值\n\n请注意，ORDER BY子句总是SELECT语句中的最后一个子句\n\n要对多列进行排序，可以用逗号分隔ORDER BY子句中的每列。\n\n不需要指定用于排序数据的列名称。如果您愿意，可以使用ORDER BY子句中列的位置。请参考下语句：\n123SELECT name, credit_limit,addressFROM customersORDER BY 2 DESC, 1;\n\n\n\n在这个例子中，name列的位置是1，credit_limit列的位置是2\n\n当使用非NULL值对混合NULL进行排序时，Oracle允许指定哪个应该首先出现。要放置NULL值在后面，可以使用NULLS LAST\nORDERBY子句可在一列上应用一个函数，例如字符串函数，数学函数等，并按函数的结果对数据进行排序。例如，以下语句使用ORDER BY子句中的UPPER()函数来区分客户名称的大小写：123SELECT customer_id, nameFROM customersORDER BY UPPER( name );\n\n\n\nSELECT DISTINCT语句\n请注意，DISTINCT不是SQL标准的UNIQUE的同义词。总是使用DISTINCT而不使用UNIQUE是一个好的习惯。\nDISTINCT将NULL值视为重复值。如果使用SELECT DISTINCT语句从具有多个NULL值的列中查询数据，则结果集只包含一个NULL值。\n\nWHERE子句\nOracle按以下顺序评估子句：FROM WHERE和SELECT\n\n首先，FROM子句指定查询数据的表。\n其次，WHERE子句基于条件(例如product_name =&#39;Kingston&#39;过滤行记录)。\n第三，SELECT子句选择了应该返回的列。\n\n\n使用比较运算符选择行记录，除了等于(=)运算符之外，Oracle还提供了下表中所示的许多其他比较运算符：\n\n\n\n编号\n运算符\n描述\n\n\n\n1\n=\n等于\n\n\n2\n!=, &lt;&gt;\n不等于\n\n\n3\n&gt;\n大于\n\n\n4\n&lt;\n小于\n\n\n5\n&gt;=\n大于或等于\n\n\n6\n&lt;=\n小于或等于\n\n\n7\nIN\n等于值列表中的任何值\n\n\n8\nANY/SOME/ALL\n将值与列表或子查询进行比较.它必须以另一个运算符(例如：=,&gt;,&lt;)作为前缀\n\n\n9\nNOT IN\n不等于值列表中的任何值\n\n\n10\n[NOT] BETWEEN n AND m\n相当于[Not] &gt;= n且&lt;= y\n\n\n11\n[NOT] EXISTS\n如果子查询返回至少一行，则返回true\n\n\n12\nIS [NOT] NULL\n测试NULL的值\n\n\n\n\nAND和OR运算符\n在声明中使用多个逻辑运算符时，Oracle始终首先评估AND运算符。但是，可以使用括号来更改评估的顺序\n如果在语句中使用多个逻辑运算符，则Oracle会在评估NOT和AND运算符之后评估OR运算符。 但是，可以使用括号更改评估的顺序\n可以使用IN运算符来代替使用多个OR运算符\n\nFETCH子句\n语法：\n12[ OFFSET offset ROWS] FETCH  NEXT [  row_count | percent PERCENT  ] ROWS  [ ONLY | WITH TIES ]\n\nOFFSET子句指定在行限制开始之前要跳过行数。OFFSET子句是可选的。 如果跳过它，则偏移量为0，行限制从第一行开始计算。偏移量必须是一个数字或一个表达式，其值为一个数字。偏移量遵守以下规则:\n\n如果偏移量是负值，则将其视为0\nn如果偏移量为NULL或大于查询返回的行数，则不返回任何行\n如果偏移量包含一个分数，则分数部分被截断\n\n\nFETCH子句指定要返回的行数或百分比。为了语义清晰的目的，您可以使用关键字ROW而不是ROWS，FIRST而不是NEXT。 例如，以下子句的行为和产生的结果相同:\n\nFETCH NEXT 1 ROWS\nFETCH FIRST 1 ROW\n\n\nONLY | WITH TIES选项\n\n仅返回FETCH NEXT(或FIRST)后的行数或行数的百分比。    \nWITH TIES返回与最后一行相同的排序键。请注意，如果使用WITH TIES，则必须在查询中指定一个ORDER BY子句。如果不这样做，查询将不会返回额外的行。\n\n\n\nLIKE运算符\nLIKE运算符的语法：expresion [NOT] LIKE pattern [ ESCAPE escape_characters ]\n在上面的语法中，\nexpression - 该表达式是一个列名称或一个表达式，要针对该模式(pattern)进行测试\npattern - 该模式是在表达式中搜索的字符串。此模式包含以下通配符：\n％(百分号)匹配零个或多个字符的任何字符串\n_(下划线)匹配任何单个字符\n\n\nescape_character - escape_character是出现在通配符前面的字符，用于指定通配符不应被解释为通配符而是常规字符。\nescape_character(如果指定)必须是一个字符，并且没有默认值\n\n\nESCAPE子句允许查找包含一个或多个通配符的字符串。 例如，表可能包含具有百分比字符的数据，例如折扣值，折旧率。要搜索字符串25％，可以使用ESCAPE子句，如下所示： LIKE &#39;%25!%%&#39; ESCAPE &#39;!&#39; 如果不使用ESCAPE子句，则Oracle将返回字符串为25的任何行\n\nJOIN语法INNER JOIN\n查询通过基于连接谓词组合表T1和T2的列值来返回结果集。它将表T1的每一行与表T2的行进行比较，以查找满足连接谓词的所有行记录。只要通过匹配非NULL值来满足连接谓词，则T1和T2表的每对匹配行的列值就会被合并到结果集中的一行中\n除ON子句外，还可以使用USING子句指定在连接表时要测试哪些列的相等性  \n请注意，USING子句中列出的列(如c1和c2)必须在T1和T2表中都存在(可用)\n\n\n\nLEFT JOIN\n左连接(Left join)返回左表中的所有行，并从右表中返回匹配的行\nON与WHERE子句中的条件 以下语句查询获得订单ID为58的订单和销售员数据1234567891011SELECT    order_id,    status,    employee_id,    last_nameFROM    ordersLEFT JOIN employees ON    employee_id = salesman_idWHERE    order_id = 58;\n\n\n\n现在，如果将条件从WHERE子句移动到LEFT JOIN的ON子句：\n12345678910SELECT    order_id,    status,    employee_id,    last_nameFROM    ordersLEFT JOIN employees ON    employee_id = salesman_id    AND order_id = 58;\n\n在这种情况下，查询将返回所有订单，但只有订单58具有与其关联的销售员数据，请注意，对于内连接，置于ON中的条件与置于WHERE子句中的条件相同\nCROSS JOIN子句\n与其他连接(如INNER JOIN或LEFT JOIN)不同，CROSS JOIN没有连接谓词的ON子句\n\n自连接\n自连接是连接表与自身的连接。自连接对比较表中的行或查询分层数据非常有用。 自连接使用其他连接，如内连接和左连接。 另外，它使用表别名在同一查询中为表提供不同的名称。  \n\n请注意，在不使用表别名的情况下，在查询中多次引用同一个表会导致错误。  \n\n 以下说明了表T如何与自身连接：\n123456SELECT    column_listFROM    T t1INNER JOIN T t2 ON    join_predicate;\n\n请注意，除了INNER JOIN之外，还可以在上面的语句中使用LEFT JOIN\n\n\nGROUP BY子句\nGROUP BY子句在SELECT语句中用于按行或表达式的值将行组合到分组汇总的行中。 GROUP BY子句为每个分组返回一行。\nGROUP BY子句出现在FROM子句之后。在有提供WHERE子句的情况下，GROUP BY子句必须放在WHERE子句之前。 GROUP BY子句按分组列中的值(如c1，c2和c3)对进行分组。GROUP BY子句只能包含聚合或分组的列。\n\nHAVING子句\nHAVING子句是SELECT语句的可选子句。它用于过滤由GROUP BY子句返回的行分组。 这就是为什么HAVING子句通常与GROUP BY子句一起使用的原因。\n请注意，HAVING子句过滤分组的行，而WHERE子句过滤行。这是HAVING和WHERE子句之间的主要区别。\nHAVING子句为什么不能使用列的别名： 虽然聚合函数在GROUP BY之前执行，但是只有在SELECT执行后才能产生别名，而SELECT在GROUP BY后执行，同理，因为ORDER BY在SELECT后执行，所以可以使用列的别名\n\n子查询\n子查询嵌套在外部查询中。请注意，子查询必须出现在括号内。\n嵌套在SELECT语句的FROM子句中的子查询称为内联视图。请注意，其他RDBMS(如MySQL和PostgreSQL)使用术语派生表，而不是内联视图。 嵌套在SELECT语句的WHERE子句中的子查询称为嵌套子查询。\n子查询可以包含另一个子查询。Oracle允许在顶级查询的FROM子句中使用无限数量的子查询级别，并在WHERE子句中使用多达255个子查询级别。\n下面是子查询的主要优点：\n提供一种替代方法来解决查询需要复杂联接和联合的数据\n使复杂的查询更具可读性\n允许以一种可以隔离每个部分的方式来构建复杂的查询\n\n\n\nExists运算符\nOracle Exists运算符是返回true或false的布尔运算符。EXISTS运算符通常与子查询一起使用来测试行的存在：  123456SELECT    *FROM    table_name    WHERE        EXISTS(subquery);\n\n\n\n如果子查询返回任何行，则EXISTS运算符返回true，否则返回false。 另外，当子查询返回第一行，EXISTS操作符终止子查询的处理。\n\n如果WHERE子句使用EXISTS运算符来检索子查询的客户，则返回相关的行。\n\n请注意，Oracle会忽略子查询中的选择列表，因此您可以使用任何列，字面值，表达式等。在上面的查询中是使用了文字数字值： 1。\n\nOracle EXISTS与INEXISTS操作符在子查询返回第一行时停止扫描行，因为它可以确定结果，而IN操作符必须扫描子查询返回的所有行以结束结果。另外，IN子句不能与NULL值进行任何比较，但EXISTS子句可以将所有值与NULL值进行比较。例如，第一个语句不返回行记录，而第二个语句返回customers表中的所有行：\n\n\n -- 第一个语句\n 123456SELECT    *FROM    customersWHERE    customer_id IN(NULL);\n\n -- 第二个语句\n 1234567891011SELECT    *FROM    customersWHERE    EXISTS (        SELECT            NULL        FROM            dual    );\n\n 通常，当子查询的结果集较大时，EXISTS运算符比IN运算符更快。相比之下，当子查询的结果集很小时，IN运算符比EXISTS运算符更快。\n\nNOT EXISTS与NOT IN 以下语句对子查询使用IN运算符：\n123456SELECT *FROM    table_nameWHERE    id IN(subquery);\n\n 假设子查询返回四个值：1,2,3和NULL。可以重写上面的整个查询，如下所示：\n123456789SELECT    *FROM    table_nameWHERE    id = 1    OR id = 2      OR id = 3    OR id = NULL;\n\n 下面的表达式总是返回一个NULL值，因为NULL值不能和任何东西比较。 id = NULL 因此，如果子查询的结果集中的任何行为NULL，则以下表达式将返回NULL值。 id NOT IN (subquery) 相比之下，NULL不会影响NOT EXIST运算符的结果，因为NOT EXISTS运算符仅检查子查询中是否存在行：\n123456SELECT    *FROM    table_nameWHERE    NOT EXISTS(subquery);\n\n 总而言之，当存在NULL值时，NOT EXISTS和NOT IN的行为会有所不同。\n\n\nANY运算符\nOracle ANY运算符用于将值与子查询返回的值或结果集列表进行比较。下面举例说明ANY运算符与列表或子查询一起使用时的语法：operator ANY ( v1, v2, v3)operator ANY ( subquery)在这个语法中：\nANY运算符前面必须有一个运算符，例如：=，!=，&gt;，&gt;=，&lt;，&lt;=。\n列表或子查询必须用圆括号包围。\n\n\n如果使用ANY运算符将一个值与子查询返回的结果集进行比较，则Oracle使用EXISTS运算符将查询转换为等效的查询，而不使用ANY运算符。\n请注意，如果子查询不返回任何行，则以下条件的计算结果为false：operator ANY (subquery)因此，整个查询不返回行\n在Oracle中，SOME和ANY的行为完全相同，因此它们完全可以互换\n\nALL操作符\nOracle ALL操作符用于将值与子查询返回的值列表或结果集进行比较。以下显示了与列表或子查询一起使用的ALL运算符的语法：operator ALL ( v1, v2, v3)operator ALL ( subquery)在这个语法中，  \nALL运算符前面必须有一个运算符，例如：=，!=,&gt;，&gt;=，&lt;，&lt;=，后跟一个列表或子查询。\n列表或子查询必须用圆括号包围。\n\n\n使用ALL运算符将值与列表进行比较时，Oracle将初始条件扩展到列表的所有元素，并使用AND运算符将它们组合在一起，如下所示：123456789101112131415161718192021SELECT    *FROM    table_nameWHERE    c &gt; ALL (        v1,        v2,        v3    );--  以上语句转换为 ALL 运算符后SELECT    *FROM    table_nameWHERE    c &gt; v1    AND c &gt; v2    AND c &gt; v3;\n\n\n\n如果使用ALL运算符将值与子查询返回的结果集进行比较，则Oracle执行两步转换，如下所示：\n12345678910111213141516171819202122232425262728293031SELECT product_name,       list_priceFROM productsWHERE list_price &gt; ALL    ( SELECT list_price     FROM products     WHERE category_id = 1 )ORDER BY product_name;-- 1st step: transformation that uses ANYSELECT product_name,       list_priceFROM products p1WHERE NOT( p1.list_price &lt;= ANY            (SELECT list_price             FROM products p2             WHERE category_id = 1 ))ORDER BY product_name; -- 2nd step: transformation that eliminates ANYSELECT product_name,       list_priceFROM products p1WHERE NOT EXISTS    (SELECT p2.list_price     FROM products p2     WHERE p2.category_id = 1       AND p2.list_price &gt;= p1.list_price )ORDER BY product_name;\n\n\n如果子查询不返回行，则以下条件的计算结果为true：operator ALL (subquery)这意味着在WHERE子句中使用上述条件的查询将返回所有行，以防子查询返回任何行。  123456SELECT    *FROM    table_nameWHERE    col operator ALL(subquery);\n\n\n\nUNION运算符\nUNION运算符是一个集合运算符，它将两个或多个SELECT语句的结果集组合到一个结果集中。 以下说明了组合两个查询的结果集的UNION运算符的语法：123456789SELECT    column_list_1FROM    T1UNION SELECT    column_list_1FROM    T2;\n\n\n\n在此声明中，column_list_1和column_list_2必须具有相同顺序的相同列数。 另外，对应列的数据类型必须是相同的数据类型组，例如数字或字符。\n\n要对由UNION运算符返回的结果集进行排序，可以将ORDER BY子句添加到最后一个SELECT语句中\nUNION运算符删除(消除)重复的行，UNION ALL操作符不会删除重复的行\nUNION将结果集放置在另一个上面，这意味着它将垂直地附加结果集。但是，诸如INNER JOIN或LEFT JOIN的连接将结果集水平组合。\n\nINTERSECT运算符\nINTERSECT运算符来比较两个查询，并返回由两者相交的行\n与UNION运算符相似，使用INTERSECT运算符时必须遵循以下规则：\n两个查询中列的数量和顺序必须相同。\n相应列的数据类型必须处于相同的数据类型组中，例如数字或字符。        \n\n\n\nMINUS操作符\nMINUS运算符比较两个查询，并返回第一个查询中但不是第二个查询输出的行。 换句话说，MINUS运算符从一个结果集中减去另一个结果集。\n与UNION和INTERSECT操作符类似，上面的查询必须符合以下规则：\n列数和它们的顺序必须匹配一致。\n相应列的数据类型必须处于相同的数据类型组中，例如数字或字符。\n\n\n\nINSERT语句\n要将新行插入到表中，请按如下方式使用INSERT语句：12INSERT INTO table_name (column_1, column_2, column_3, ... column_n)VALUES( value_1, value_2, value_3, ..., value_n);\n\n\n\n在这个声明语句中：    * 首先，指定要插入的表的名称 - table_name。    * 其次，在圆括号内指定逗号分隔列名的列表。    * 第三，指定对应于列列表的逗号分隔值列表。\n如果值列表与表列具有相同的顺序，则可以跳过不指定列的列表，但**这不被认为是一种好的做法**：\n12INSERT INTO table_nameVALUES (value_1, value_2, value_3, ..., value_n);\n\n如果从`INSERT`语句中排除一列或多列，则必须指定列列表，因为Oracle需要它与值列表中的值相匹配。   \n在`INSERT`语句中省略的列**将使用缺省值(如果可用)或者如果列接受`NULL`值，则使用`NULL`值**。INSERT INTO SELECT语句\n有时候，想要将从其它表中选择数据并将其插入到另一个表中。要做到这一点，可使用INSERT INTO SELECT语句，如下所示：123456INSERT INTO target_table (col1, col2, col3)SELECT col1,       col2,       col3FROM source_tableWHERE condition;\n\n\n\nINSERT INTO SELECT语句要求源表和目标表匹配数据类型。\nInsert All语句\nOracle提供了两种类型的多项式插入语句：无条件的和有条件的。\n无条件的INSERT ALL语句将多行插入到表中，要将多行插入到表中，请使用以下INSERT ALL语句：12345INSERT ALL    INTO table_name(col1,col2,col3) VALUES(val1,val2, val3)    INTO table_name(col1,col2,col3) VALUES(val4,val5, val6)    INTO table_name(col1,col2,col3) VALUES(val7,val8, val9)Subquery;\n\n\n\n在这个语句中，每个值表达式值：val1，val2或val3必须引用由子查询的选择列表返回的列对应的值。如果要使用文字值而不是子查询返回的值，请使用以下子查询：SELECT * FROM dual;\n\n有条件的INSERT ALL语句条件多项插入语句允许根据指定的条件将行插入到表中。以下显示了条件多项插入语句的语法：  12345678INSERT [ ALL | FIRST ]    WHEN condition1 THEN        INTO table_1 (column_list ) VALUES (value_list)    WHEN condition2 THEN         INTO table_2(column_list ) VALUES (value_list)    ELSE        INTO table_3(column_list ) VALUES (value_list)Subquery\n\n\n\n如果指定了ALL关键字，则Oracle将在WHEN子句中评估每个条件。如果条件评估/计算为true，则Oracle执行相应的INTO子句。但是，当指定FIRST关键字时，对于由子查询返回的每一行，Oracle都会从WHEN子句的上下方向评估每个条件。 如果Oracle发现条件的计算结果为true，则执行相应的INTO子句并跳过给定行的后续WHEN子句。请注意，单条件多项式插入语句最多可以有127个WHEN子句。\n\nINSERT ALL限制Oracle多表插入语句受以下主要限制：  \n它可以用来将数据只插入到表中，而不是视图或物化视图。  \n它不能用来将数据插入到远程表中。  \n所有INSERT INTO子句中的列总和不得超过999。  \n一个表集合表达式不能在一个多表插入语句中使用。  \n多表插入语句的子查询不能使用序列。\n\n\n\nDelete语句\n要从表中删除一行或多行，请按如下所示使用DELETE语句：\n 12345DELETEFROM    table_nameWHERE    condition;\n\n 在这个语句中，\n\n首先，指定要从中删除数据的表的名称。\n\n其次，通过使用WHERE子句中的条件指定应该删除哪些行。如果省略了WHERE子句，则DELETE语句将从表中删除所有行。\n请注意，使用TRUNCATE TABLE语句删除大型表中的所有行会更快更高效。\n\n\n\n级联删除在现实应用中，经常从与其他表中的行具有外键关系的表中来删除行记录。例如，想要从orders表中删除id为1的销售订单，并从order_items表中删除与订单id是1关联的所有行项目。 通常可以发出两个DELETE语句，如下所示：\n12345678910111213-- 第一条DELETE FROM    ordersWHERE    order_id = 1;-- 第二条DELETE FROM    order_itemsWHERE    order_id = 1;COMMIT WORK;\n\n\n\n请注意，COMMIT WORK语句确保两个DELETE语句以全部或全部方式执行，以防第一条语句成功，但第二个DELETE语句失败时在order_items表中的孤行。但是，如果知道如何正确设置表的约束，那么这是不必要的。在这种情况下，当创建order_items表时，可以使用DELETE CASCADE选项定义一个外键约束，如下所示：\n12345678910CREATE TABLE order_items (    order_id   NUMBER( 12, 0 )                                ,     -- other columns    -- ...    CONSTRAINT fk_order_items_orders     FOREIGN KEY( order_id )     REFERENCES orders( order_id )     ON DELETE CASCADE);\n\n通过这样做，每当从orders表中删除一行时，例如：\n12345DELETEFROM    ordersWHERE    order_id = 1;\n\norder_items表中order_id为1的所有行也被数据库系统自动删除\nMerge语句\nMERGE语句从一个或多个源表中选择数据并更新或将其插入到目标表中。 MERGE语句可指定一个条件来确定是更新数据还是将数据插入到目标表中。以下说明了MERGE语句的语法：1234567891011MERGE INTO target_table USING source_table ON search_condition    WHEN MATCHED THEN        UPDATE SET col1 = value1, col2 = value2,...        WHERE &lt;update_condition&gt;        [DELETE WHERE &lt;delete_condition&gt;]    WHEN NOT MATCHED THEN        INSERT (col1,col2,...)        values(value1,value2,...)        WHERE &lt;insert_condition&gt;;\n\n\n\n下面来仔细看看上面MERGE语句的语法：    * 首先，指定要在INTO子句中更新或插入的目标表(target_table)。    * 其次，指定要更新或插入USING子句中的数据源(source_table)。    * 第三，指定合并操作在ON子句中更新或插入的搜索条件。\n\n对于目标表中的每一行，Oracle都会评估搜索条件：  \n\n如果结果为true，则Oracle使用源表(source_table)中的相应数据更新该行。  \n\n如果任何行的结果为false，则Oracle将源表(source_table)中相应的行插入到目标表(target_table)中。\n当想要在单个操作中组合多个INSERT，UPDATE和DELETE语句时，MERGE语句变得很方便。因为MERGE是确定性语句，所以不能在同一个MERGE语句中多次更新目标表的同一行。可以将一个可选的DELETE WHERE子句添加到MATCHED子句中，以在合并操作之后进行清理。DELETE子句只删除目标表中与ON和DELETE WHERE子句匹配的行。\n\n\n\nMERGE前提条件 要执行MERGE语句，必须在源表上具有INSERT和UPDATE对象权限。 如果使用DELETE子句，则还必须在目标表上具有DELETE对象特权。\n\n\nCreate Table语句\n要在Oracle数据库中创建一个新表，可以使用CREATE TABLE语句。下面说明了CREATE TABLE语句的基本语法：123456CREATE TABLE schema_name.table_name (    column_1 data_type column_constraint,    column_2 data_type column_constraint,    ...    table_constraint );\n\n\n\n在上面这个语法中，    * 首先，在CREATE TABLE子句中，指定新表所属的表名和模式名称。    * 其次，在圆括号内列出所有列。 如果一个表有多个列，则需要用逗号分隔每个列的定义。列定义包括列名    * ，后跟它的数据类型，例如NUMBER，VARCHAR2和列约束，如NOT NULL，主键，约束检查等。    * 第三，如果适用，例如：主键，外键，约束检查，则为表添加约束。\n\n请注意用户权限问题，必须具有CREATE TABLE系统特权才能在模式中创建新表，并使用CREATE ANY TABLE系统特权在其他用户的模式中创建新表。除此之外，新表的所有者必须具有包含新表或UNLIMITED TABLESPACE系统特权的表空间的配额。\n\nDrop Table语句\n要将表移动到回收站或将其从数据库中完全删除，请使用DROP TABLE语句：12DROP TABLE schema_name.table_name[CASCADE CONSTRAINTS | PURGE];\n\n\n\n在这个语句中：    * 首先，指出要在DROP TABLE子句之后删除的表及其模式。如果不明确指定模式名称，则该语句假定将从模式中删除该表。    * 其次，指定CASCADE CONSTRAINTS子句删除引用表中主键和唯一键的所有参照完整性约束。     如果存在这种引用完整性约束，并且不使用此子句，Oracle将返回错误并停止删除表。    * 第三，如果想删除表格并且一次释放与之关联的空间，指定PURGE子句。 通过使用PURGE子句，Oracle不会将表及其依赖对象放入回收站。\n\n请注意，PURGE子句不允许您回滚或恢复删除的表。 因此，如果不希望敏感数据出现在回收站中，这很有用。\n\nAlter Table Modify列语句\n要更改表中列的定义，请按如下所示使用ALTER TABLE MODIFY列语法：12ALTER TABLE table_name MODIFY column_name action;\n\n\n\n语句很直接。要修改表的列，需要指定要执行的列名，表名和操作。Oracle允许执行多种操作，但以下是主要常用的操作：    * 修改列的可见性    * 允许或不允许NULL值    * 缩短或扩大列的大小    * 更改列的默认值    * 修改虚拟列的表达式\n要修改多个列，请使用以下语法：123456ALTER TABLE table_nameMODIFY (    column_name_1 action,    column_name_2 action,    ...);\n\n\n修改列的可见性 可以将表列定义为不可见或可见。不可见列不可用于查询，但是，可以通过在查询中显式指定不可见列来查询 默认情况下，表列是可见的。可以在创建表或使用ALTER TABLE MODIFY列语句时定义不可见列。 例如，以下语句使full_name列不可见：12ALTER TABLE accounts MODIFY full_name INVISIBLE;\n\n\n\n要将列从不可见变为可见，请使用以下语句：\n12ALTER TABLE accounts MODIFY full_name VISIBLE;\n\n\n允许或不允许null示例 以下语句将email列更改为接受非空(not null)值：12ALTER TABLE accounts MODIFY email VARCHAR2( 100 ) NOT NULL;\n\n\n\n但是，Oracle发出以下错误：SQL Error: ORA-02296: cannot enable (OT.) - null values found因为当将列从可为null改为not null时，必须确保现有数据符合新约束(也就是说，如果原来数据中NULL是不行的)。为了解决这个问题，首先更新email列的值，然后改变email列的约束\n\n扩大或缩短列示例的大小12ALTER TABLE accounts MODIFY phone VARCHAR2( 24 );\n\n\n\n要缩短列的大小，请确保列中的所有数据都符合新的大小\n\n修改虚拟列 可以更改虚拟列full_name的表达式，如下所示：\n123ALTER TABLE accounts MODIFY full_name VARCHAR2(52) GENERATED ALWAYS AS (last_name || ', ' || first_name);\n\n修改列的默认值添加一个名为status的新列，默认值为1到accounts表中。参考以下语句 -\n12ALTER TABLE accountsADD status NUMBER( 1, 0 ) DEFAULT 1 NOT NULL ;\n\n\n\n当执行了该语句，就会将accounts表中的所有现有行的status列中的值设置为1\nTRUNCATE TABLE语句\n如果要从表中删除所有数据，可以使用不带WHERE子句的DELETE语句，如下所示：DELETE FROM table_name;对于有少量行记录的表，DELETE语句做得很好。 但是，当拥有大量行记录的表时，使用DELETE语句删除所有数据效率并不高。Oracle引入了TRUNCATE TABLE语句，用于删除大表中的所有行。\n\nTRUNCATE TABLE语句的语法：\n1234TRUNCATE TABLE schema_name.table_name[CASCADE][[ PRESERVE | PURGE] MATERIALIZED VIEW LOG ]][[ DROP | REUSE]] STORAGE ]\n\nTRUNCATE TABLE CASCADE语句删除table_name表中的所有行，并递归地截断链中的关联表。\n\n请注意，TRUNCATE TABLE CASCADE语句需要使用ON DELETE CASCADE子句定义的外键约束才能工作。\n\n 通过MATERIALIZED VIEW LOG子句，可以指定在表上定义的物化视图日志是否在截断表时被保留或清除。 默认情况下，物化视图日志被保留。  \n STORAGE子句允许选择删除或重新使用由截断行和关联索引(如果有的话)释放的存储。 默认情况下，存储被删除。\n\n请注意，要截断表，它必须在您自己的模式中，或者必须具有DROP ANY TABLE系统权限。\n\n\n\nRename表语句\n要重命名表，可以使用以下Oracle RENAME表语句，如下所示：1RENAME table_name TO new_name;\n\n\n\n在RENAME表语句中：    * 首先，指定将要重命名的表名称。    * 其次，指定新的表名。新名称不能与同一模式中的另一个表相同。\n&gt; 请注意，一旦执行了RENAME语句，就**不能回滚**了。\n\n当重命名表时，Oracle自动将旧表上的索引，约束和授权转移到新表上。 另外，它使依赖重命名表(原表)的所有对象失效，如**视图，存储过程，函数和同义词**。数据类型\nOracle具有下表中所示的一些内置数据类型：\n\n\n\n代码\n数据类型\n\n\n\n1\nVARCHAR2(size [BYTE / CHAR])\n\n\n1\nNVARCHAR2(size)\n\n\n2\nNUMBER[(precision [, scale])]\n\n\n8\nLONG\n\n\n12\nDATE\n\n\n22\nBINARY_DOUBLE\n\n\n23\nRAW(size)\n\n\n34\nLONG RAW\n\n\n69\nROWID\n\n\n96\nCHAR [(size [BYTE / CHAR])]\n\n\n96\nNCHAR[(size)]\n\n\n112\nCLOB\n\n\n112\nNCLOB\n\n\n113\nBLOB\n\n\n114\nBFILE\n\n\n180\nTIMESTAMP [(fractional_seconds)]\n\n\n181\nTIMESTAMP [(fractional_seconds)] WITH TIME ZONE\n\n\n182\nINTERVAL YEAR [(year_precision)] TO MONTH\n\n\n183\nINTERVAL DAY [(day_precision)] TO SECOND[(fractional_seconds)]\n\n\n208\nUROWID [(size)]\n\n\n231\nTIMESTAMP [(fractional_seconds)] WITH LOCAL TIMEZONE\n\n\n\n每种数据类型都有由Oracle内部管理的代码。要查找列中值的数据类型代码，请使用DUMP()函数。\n\n\n字符数据类型 字符数据类型由:CHAR，NCHAR，VARCHAR2，NVARCHAR2和VARCHAR组成。NCHAR和NVARCHAR2数据类型用于存储Unicode字符串。 固定长度字符数据类型是CHAR，NCHAR，可变长度字符数据类型是：VARCHAR2和NVARCHAR2。 VARCHAR是VARCHAR2的同义词。但是，不建议使用VARCHAR，因为Oracle将来可能会更改它的语义。 对于字符数据类型，可以用字节或字符指定它们的大小。\n\n数字数据类型 NUMBER数据类型具有精度p和比例s。精度范围从1到38，范围从-84到127。 如果不指定精度，那么该列可以存储包括定点数和浮点数的值。比例的默认值是零。\n\n日期时间和时间间隔数据类型 日期时间数据类型是DATE，TIMESTAMP，TIMESTAMP WITH TIME ZONE和TIMESTAMP WITH LOCAL TIME ZONE。 日期时间数据类型的值是日期时间。 区间数据类型为INTERVAL YEAR TO MONTH和INTERVAL DAY TO SECOND。 区间数据类型的值是区间。\n\nRAW和LONG RAW数据类型 RAW和LONG RAW数据类型用于存储二进制数据或字节字符串，例如文档，声音文件和视频文件的内容。 RAW数据类型最多可以存储2000字节，而LONG RAW数据类型最多可以存储2GB。\n\nBFILE数据类型 BFILE数据类型将定位器存储到位于数据库之外的大型二进制文件。 定位器由目录和文件名组成。\n\nBLOB数据类型 BLOB代表二进制大对象。可以使用BLOB数据类型来存储最大大小为(4千兆字节 - 1)*(数据库块大小)的二进制对象。\n\nCLOB数据类型 CLOB代表字符大的对象。使用CLOB存储单字节或多字节字符，最大大小为(4千兆字节 - 1)*(数据库块大小)。\n\n请注意，CLOB支持固定字符集和变量字符集。\n\n\nNCLOB数据类型NCLOB与CLOB类似，不同的是它可以存储Unicode字符。\n\nUROWID数据类型UROWID主要用于ROWID伪列返回的值。它的值是基本的64个字符串，它们表示表中行的唯一地址。\n\n数据类型：Oracle和ANSI将ANSI数据类型用于列定义时，Oracle将根据以下映射表将Oracle转换为其相应的数据类型：\n\n\n\nANSI SQL数据类型\nOracle SQL数据类型\n\n\n\nCHARACTER(n), CHAR(n)\nCHAR(n)\n\n\nCHARACTER VARYING(n), CHAR VARYING(n)\nVARCHAR2(n)\n\n\nNATIONAL CHARACTER(n), NATIONAL CHAR(n), NCHAR(n)\nNCHAR(n)\n\n\nNATIONAL CHARACTER VARYING(n), NATIONAL CHAR VARYING(n), NCHAR VARYING(n)\nNVARCHAR2(n)\n\n\nNUMERIC(p,s), DECIMAL(p,s) (a)\nNUMBER(p,s)\n\n\nINTEGER, INT, SMALLINT\nNUMBER(38)\n\n\nFLOAT (b), DOUBLE PRECISION (c), REAL (d)\nNUMBER\n\n\n\n\nNumber数字类型\nNUMBER数据类型用于存储可能为负值或正值的数值。以下说明了NUMBER数据类型的语法：1NUMBER[(precision [, scale])]\n\n\n\nNUMBER数据类型具有以下精度和尺度。    * 精度是一个数字中的位数。 范围从1到38。    * 尺度是数字中小数点右侧的位数。 范围从-84到127。\n例如，数字1234.56的精度是6，尺度是2。所以要存储这个数字，需要定义为：NUMBER(6,2)。  \n精度和尺度都是十进制数字，可选。 如果跳过精度和小数位，Oracle**使用数字的最大范围和精度。**\n请注意，如果在NUMBER(p，s)列中插入数字，并且数字超过精度p，则Oracle将发出错误。 但是，如果数量超过尺度s，则Oracle将对该值进行四舍五入。\nNUMBER数据类型别名\n\n\n\n\nANSI数据类型\nOracle NUMBER数据类型\n\n\n\nINT\nNUMBER(38)\n\n\nSMALLINT\nNUMBER(38)\n\n\nNUMBER(p,s)\nNUMBER(p,s)\n\n\nDECIMAL(p,s)\nNUMBER(p,s)\n\n\n\n请注意，INT，SMALLINT，NUMERIC和DECIMAL只是别名。它们不是真正的数据类型。 Oracle在内部将这些别名映射到相应的NUMBER数据类型。\n\nFloat类型\nFLOAT数据类型是NUMBER数据类型的子类型。 其主要目的是促进与ANSI SQL FLOAT数据类型的兼容。\n以下显示FLOAT数据类型的语法：1FLOAT(p)\n\n\n\n我们只能指定FLOAT数据类型的精度。不能指定尺度，因为Oracle数据库从数据中解析尺度的。 FLOAT的最大精度是126。\n\n在FLOAT中，精度是二进制位，而在NUMBER中精度是十进制数。可以使用以下公式在二进制和十进制精度之间进行转换：1P(d) = 0.30103 * P(b)\n\n\n\n根据这个公式，因二进制精度的最大126位数，大致等于十进制数位数的38位数。\n\n为了使它与SQL ANSI FLOAT兼容，Oracle提供了一些别名，如下表所示：\n\n\n\nANSI SQL FLOAT\nOracle FLOAT\n\n\n\nFLOAT\nFLOAT(126)\n\n\nREAL\nFLOAT(63)\n\n\nDOUBLE PRECISION\nFLOAT(126)\n\n\n 例如，不使用FLOAT(63)数据类型，可以使用REAL别名代替。\n\n\nChar类型\nCHAR数据类型用于存储固定长度的字符串。 CHAR数据类型可以存储1到2000字节的字符串。\n要定义一个CHAR列，需要用字节或字符来指定一个字符串长度，如下所示：12CHAR(length BYTE)CHAR(length CHAR)\n\n\n\n如果没有明确指定BYTE或CHAR，那么Oracle会默认使用BYTE。如果像下面的例子那样不指定长度，那么长度的默认值是1。\n1column_name CHAR\n\n插入或更新固定长度字符串列时，Oracle将字符存储为固定长度数据。 这意味着如果存储的值的长度小于列中定义的最大长度，则Oracle将空格填充到最大长度的字符串。 如果插入一个长度大于列的值，Oracle会返回一个错误。\n&gt; **Oracle使用空格填充后来比较CHAR值**。\n在比较长度不等的字符类型的字符串时，Oracle使用非空格字符填充语义。要使其工作，需要使用RTRIM()函数从CHAR数据中去除空格，然后将其与输入字符串进行比较\n\nNChar类型\nNCHAR数据类型用于存储固定长度的Unicode字符数据。NCHAR的字符集只能是AL16UTF16或UTF8，在数据库创建时指定为国家字符集。\n当使用NCHAR列创建表时，NCHAR列的最大大小始终在字符长度语义中，例如：123CREATE TABLE nchar_demo (    description NCHAR(10));\n\n\n\n在本例中，description列的最大长度是10个字符。对于NCHAR列的最大大小，不可能使用字节长度，如下所示：\n1description NCHAR(10 BYTE) -- not possible\n\nNCHAR列的最大字节长度取决于当前的国家字符集。 它是每个字符中最大字符长度和最大字节数的乘积。要查找当前的国家字符集，请使用以下语句：\n123456SELECT    *FROM    nls_database_parametersWHERE    PARAMETER = 'NLS_NCHAR_CHARACTERSET';\n\nAL16UTF16字符集使用2个字节存储一个字符，所以description列的最大字节长度为20个字节。  \n\nOracle将NCHAR列的最大长度限制为2000字节。 这意味着一个NCHAR列只能容纳2000字符的1字节字符或1000个字符的2字节字符。\n\n\nNCHAR与CHAR比较/区别首先，NCHAR的最大长度只在字符长度语义上，而CHAR的最大长度可以是字符长度或字节长度语义。其次，NCHAR将字符存储在国家默认字符集中，而CHAR将字符存储在默认字符集中。以下语句返回由CHAR使用的默认字符集和由NCHAR使用的默认国家字符集：123456789SELECT    *FROM    nls_database_parametersWHERE    PARAMETER IN(        'NLS_CHARACTERSET',        'NLS_NCHAR_CHARACTERSET'    );\n\n\n\nVarchar2类型\n要存储可变长度的字符串，可以使用VARCHAR2数据类型。 VARCHAR2列可以存储1到4000字节的值。 这意味着对于单字节字符集，最多可以在VARCHAR2列中存储4000个字符。\n当使用VARCHAR2列创建表时，必须指定最大字符串长度(以字节为单位)：1VARCHAR2(max_size BYTE)\n\n\n\n或以字符\n1VARCHAR2(max_size CHAR)\n\n默认情况下，如果没有在max_size之后显式指定BYTE或CHAR，则Oracle使用BYTE。 换句话说，VARCHAR2(N)列最多可以容纳N个字节的字符。如果存储大小超过VARCHAR2列最大长度的字符串，则Oracle发出错误。\n\n如果在VARCHAR2(20)列中存储10个字符，则Oracle仅使用10个字节进行存储，而不是20个字节。 因此，使用VARCHAR2数据类型可以帮助您节省表使用的空间。  \n\n比较VARCHAR2值时，Oracle使用非填充比较语义。\n\n从Oracle 12c开始，可以为VARCHAR2数据类型最大长度为：32767。 Oracle使用MAX_STRING_SIZE参数来控制最大长度。 如果MAX_STRING_SIZE是STANDARD，则VARCHAR2的最大大小是4000字节。 如果MAX_STRING_SIZE为EXTENDED，则VARCHAR2的大小限制为32767。要获取MAX_STRING_SIZE参数的值，请使用以下查询：1234567SELECT    name,    valueFROM    v$parameterWHERE    name = 'max_string_size';\n\n\n\nDate类型\nDATE数据类型允许以一秒的精度存储包括日期和时间的时间点值。DATE数据类型存储年份(包括世纪)，月份，日期，小时数，分钟数和秒数。 它的范围从公元前4712年1月1日到公元9999年12月31日(共同时代)。 默认情况下，如果未明确使用BCE，则Oracle使用CE日期条目。\nOracle数据库有其自己的专用格式来存储日期数据。它使用7个字节的固定长度的字段，每个字段对应于世纪，年，月，日，时，分和秒来存储日期数据。\nOracle日期格式输入和输出的标准日期格式是DD-MON-YY，例如由NLS_DATE_FORMAT参数的值表示为：01-JAN-17。以下语句显示了NLS_DATE_FORMAT参数的当前值：123456SELECT  valueFROM  V$NLS_PARAMETERSWHERE  parameter = 'NLS_DATE_FORMAT';\n\n\n\n在Oracle数据库系统中，NLS_DATE_FORMAT的值是：\n1DD-MON-RR\n\n以下语句通过使用SYSDATE函数以标准日期格式返回当前日期。\n1234SELECT  sysdateFROM  dual;\n\n\n假设想要将标准日期格式更改为YYYY-MM-DD，那么可以使用ALTER SESSION语句来更改NLS_DATE_FORMAT参数的值，如下所示：\n1ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';\n\n使用TO_CHAR()函数格式化日期TO_CHAR()函数采用DATE值作为参数，根据指定的格式对其进行格式化，并返回一个日期字符串。例如，要以特定的格式显示当前的系统日期，请按如下所示使用TO_CHAR()函数：\n1234SELECT  TO_CHAR( SYSDATE, 'MM/DD/YYYY' )FROM  dual;\n\n将字符串转换为日期由于Oracle使用内部格式来存储DATE数据，因此在将日期值存储到日期列之前，通常必须将字符串转换为日期值。要转换不是标准格式的日期值，可以使用带有格式字符串的TO_DATE()函数。以下示例使用TO_DATE()函数将字符串“August 01，2017”转换为相应的日期：\n12345-- alter session set nls_language='SIMPLIFIED CHINESE';SELECT  TO_DATE('2018-10-21', 'YYYY-MM-DD' )FROM  dual;\n\n日期文字除了使用TO_DATE()函数之外，还可以使用以下语法将日期值指定为字符串文字：\n1DATE 'YYYY-MM-DD'\n\n\n\n请注意，要使用日期作为文字，必须使用公历。 以下示例显示2017年8月1日的ANSI日期字面值：\n1DATE '2017-08-01'\n\nANSI日期文字没有时间部分，必须采用确切格式(‘YYYY-MM-DD’)。 如果要将时间数据包含在日期值中，则必须使用上面介绍的TO_DATE()函数。\nTimestamp类型\nTIMESTAMP数据类型用于存储日期和时间数据，包括年，月，日，时，分和秒。另外，它存储小数秒，它不是由DATE数据类型存储的。要定义TIMESTAMP列，请使用以下语法：1column_name TIMESTAMP[(fractional_seconds_precision)]\n\n\n\nfractional_seconds_precision指定SECOND字段小数部分的位数。它的范围从0到9，这意味着可以使用TIMESTAMP数据类型来存储到纳秒的精度。如果省略fractional_seconds_precision，则默认为6。  以下表达式说明了如何定义TIMESTAMP列：\n123...started_at TMESTAMP(6),...\n\n在此示例中，started_at列是一个TIMESTAMP列，其分数秒精度设置为微秒。\n\nTIMESTAMP文字 要指定TIMESTAMP文字，请使用以下格式：\n1TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF'\n\n格式化TIMESTAMP值 要更改TIMESTAMP值的输出，可以使用TO_CHAR()函数，将TIMESTAMP值或列的名称作为第一个参数，将格式字符串作为第二个参数。  \n 以下语句使用TO_CHAR()函数来格式化logged_at列中的值：\n123SELECT message,    TO_CHAR(logged_at, 'MONTH DD, YYYY \"at\" HH24:MI')FROM logs;\n\n提取TIMESTAMP组件 要提取TIMESTAMP组件(如年，月，日，小时，分钟和秒)，请使用EXTRACT()函数：\n1EXTRACT( component FROM timestamp);\n\n\n\nInterval类型\nOracle提供了两种日期时间数据类型：DATE和TIMESTAMP用于存储时间点数据。另外，它提供INTERVAL数据类型用于存储一段时间。有两种类型的INTERVAL：\n\nINTERVAL YEAR TO MONTH - 间隔使用年份和月份。\nINTERVAL DAY TO SECOND - 使用包括小数秒在内的天，小时，分钟和秒存储间隔。\n\n\nINTERVAL YEAR TO MONTH INTERVAL YEAR TO MONTH数据类型使用YEAR和MONTH字段存储一段时间。 下面介绍一个INTERVAL YEAR TO MONTH：\n1INTERVAL YEAR [(year_precision)] TO MONTH\n\n year_precision代表YEAR字段中的位数。范围从0到9。 year_precision是可选的。如果省略year_precision参数，则默认为2。也就是说，默认情况下，最多可以存储99年和11个月的期限，这个期限必须小于100年。\n\nINTERVAL YEAR TO MONTH文字 要指定INTERVAL YEAR TO MONTH数据类型的文字值，可以使用以下格式：\n1INTERVAL 'year[-month]' leading (precision) TO trailing\n\n leading和trailing可以是YEAR或MONTH。 以下是参数：\n\nyear[-month]year和month是整个区间的leading和trailing的整数。 如果leading是YEAR，trailing是MONTH，那么month字段的范围从0到11。trailing列必须小于leading列。 例如，INTERVAL ‘1-2’ MONTH TO YEAR是无效的，因为leading列YEAR大于MONTH的leading字段。\nprecision是leading字段中的最大数字位数。精度范围为:0~9，默认值为2。\n\n\n下表说明了INTERVAL YEAR TO MONTH文字的示例：\n\n\n\nINTERVAL YEAR TO MONTH文字\n含意\n\n\n\nINTERVAL ‘120-3’ YEAR(3) TO MONTH\n间隔120年，3个月; 由于前导字段的值大于默认精度(2位)，因此必须指定前导字段精度YEAR(3)。\n\n\nINTERVAL ‘105’ YEAR(3)\n间隔105年0个月。\n\n\nINTERVAL ‘500’ MONTH(3)\n间隔500个月。\n\n\nINTERVAL ‘9’ YEAR\n间隔9年，相当于INTERVAL ‘9-0’ YEAR TO MONTH\n\n\nINTERVAL ‘40’ MONTH\n40个月或3年4个月，相当于INTERVAL ‘3-4’ YEAR TO MONTH\n\n\nINTERVAL ‘180’ YEAR\n无效的时间间隔，因为’180’有3个数字，它大于默认精度(2)\n\n\n\nINTERVAL DAY TO SECOND数据类型 INTERVAL DAY TO SECOND是一种按天，小时，分钟和秒钟存储一段时间。 以下显示INTERVAL DAY TO SECOND数据类型的语法：\n1INTERVAL DAY [(day_precision)] TO SECOND [(fractional_seconds_precision)]\n\n 在上面这个语法中， day_precision - 是DAY字段中的位数。取值范围是09，缺省值是2。 fractional_seconds_precision 是SECOND字段小数部分的位数。范围从09。如果省略fractional_seconds_precision，则默认为6。\n\n\nOracle主键\n主键是表中列的唯一标识表中的行的一列或多列的组合。以下是设置列成为主键的规则：\n\n主键列不能包含NULL值或空字符串。\n主键值在整个表中必须是唯一的。\n主键值不应随时间而改变。\n\n\n根据1中这些规则，以下是对主键的建议：\n\n首先，主键应该是没有意义的。 有时，您可能需要使用有意义的数据，例如：社会安全号码(SSN)，车辆识别号码(VIN)，电子邮件和电话号码等，这些数据被认为是唯一的。 但是，您不知道电子邮件或电话号码何时更改或被他人重复使用。 在这种情况下，会造成很多数据问题。\n\n其次，主键应该是紧凑的。主键通常是数字的，因为Oracle通常处理数字的速度比任何其他数据类型更快。\n\n注意：尽管在Oracle中不是强制性的，但在每个表中都有一个主键是最佳实践。\n\n\n\n\n通常，在创建表时创建表的主键。另外，通过使用ALTER TABLE语句，可以在创建表之后再添加一个主键。\n\n删除Oracle PRIMARY KEY约束一般很少会从表中删除PRIMARY KEY约束。 如果必须要删除主键，则使用以下ALTER TABLE语句。\n12ALTER TABLE table_nameDROP CONSTRAINT primary_key_constraint_name;\n\n启用/禁用Oracle PRIMARY KEY约束要在将大量数据加载到表中或更新海量数据时需要提高性能，可以暂时禁用PRIMARY KEY约束。要禁用表的主键约束，可以使用ALTER TABLE语句：\n12ALTER TABLE table_nameDISABLE CONSTRAINT primary_key_constraint_name;\n\n\n\n或者，\n12ALTER TABLE table_nameDISABLE PRIMARY KEY;\n\n要启用主键约束，请使用以下ALTER TABLE语句：\n12ALTER TABLE table_nameENABLE CONSTRAINT primary_key_constraint_name;\n\n或者，\n12ALTER TABLE table_nameENABLE PRIMARY KEY;","plink":"http://ZhongJinMing.github.io/post/Oracle-基础教程/"},{"title":"Oracle-执行顺序","date":"2019-08-13T09:02:06.000Z","updated":"2019-08-13T09:03:43.443Z","content":"Sql的执行顺序在oracle中select语句的基本结构如下：\n12345678910111  [ WITH &lt;common_table_expression&gt;]2  SELECT [DISTINCT] [TOP_SEPCIFICATION] &lt;select_list&gt; 3  [ INTO new_table ]4  FROM 5  &lt;table_source| 6  &lt;table_left&gt; [JOIN_TYPE] JOIN &lt;table_right&gt; 7  ON &lt;join_condition&gt; &gt;8  [ WHERE &lt;search_condition&gt; ]9  [ GROUP BY &lt;group_by_list&gt; ]10 [ HAVING &lt;search_condition&gt; ]11 [ ORDER BY order_expression [ ASC | DESC ] ]\n\n其中[]中的部分为可选内容，另外其中的[ WITH &lt;common_table_expression&gt;]语句是用于添加其他sql行为的，例如你可以写成create &lt;newtablename&gt; as来创建一个以之后的select语句检索到的内容为表内容的新表。而除此之外其他部分的执行顺序如下所示： \n\n执行FROM语句，如果FROM之后接的是一个表则执行步骤（4），如果接的是一个JOIN语句则执行步骤（2）； \n执行ON语句对ON之前的JOIN语句中两个表进行裁剪（这样可以避免直接进行JOIN得到全表的笛卡尔积而找出空间和时间的浪费）； \n对（2）中裁剪得到的两张表进行JOIN操作，得到一张联合的表.如果之后还有其他JOIN语句则将得到的表作为table_left继续进行步骤（2）的操作，否则进行步骤（4）； \n执行WHERE语句，根据search_condition对之前步骤得到的表进行筛选； \n执行GROUP BY语句按照group_by_list对数据进行分组； \n执行HAVING语句对用GROUP BY 分组后的数据进行筛选，HAVING跟WHERE语句的区别在于WHERE一般用于对FROM语句得到的数据进行筛选，其中的筛选条件不能是聚合函数，而HAVING一般用于对GROUP BY语句处理后的数据进行筛选，可以使用聚合函数作为判断条件； \n执行SELECT语句，对查询到的字段进行组织； \n使用DISTINCT对结果去重； \n使用ORDER BY 语句对结果进行排序； \n使用TOP指定要顺畅前几行的数据。\n\n","plink":"http://ZhongJinMing.github.io/post/Oracle-执行顺序/"},{"title":"webpack学习","date":"2019-08-13T07:49:05.000Z","updated":"2019-08-16T13:43:02.851Z","content":"安装\n要安装最新版本或特定版本，请运行以下命令之一：\n12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt;\n\n如果你使用 webpack 4+ 版本，你还需要安装 CLI。\n1npm install --save-dev webpack-cli\n\n\n\ncss-loader以字符串形式读取CSS文件。你可以用raw-loader在很多情况下都会产生同样的效果。因为它只读取文件内容而没有其他内容，所以它基本上是无用的，除非你用另一个加载程序将它链接起来。\nstyle-loader获取这些样式并创建&lt;style&gt;页中的标记&lt;head&gt;包含这些样式的元素。\n如果你看一下里面的javascript bundle.js使用后style-loader你将在生成的代码中看到一个注释：\n\n//Style-Loader：通过添加标记向DOM添加一些CSS\n\n","plink":"http://ZhongJinMing.github.io/post/webpack学习/"}]